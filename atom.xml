<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>贝西晨的Blog呀</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2023-08-26T08:58:44.651Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>beixichen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Java】Java GC相关问题</title>
    <link href="http://yoursite.com/2021/03/15/Java%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/JVM/"/>
    <id>http://yoursite.com/2021/03/15/Java基本知识/JVM/</id>
    <published>2021-03-15T13:29:14.000Z</published>
    <updated>2023-08-26T08:58:44.651Z</updated>
    
    <content type="html"><![CDATA[<p>JVM gc</p><p>什么样的对象会从新生代到老年代</p><p>新生代的垃圾回收算法</p><p>老年代的垃圾回收算法</p><p>常用的GC算法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JVM gc&lt;/p&gt;
&lt;p&gt;什么样的对象会从新生代到老年代&lt;/p&gt;
&lt;p&gt;新生代的垃圾回收算法&lt;/p&gt;
&lt;p&gt;老年代的垃圾回收算法&lt;/p&gt;
&lt;p&gt;常用的GC算法&lt;/p&gt;

      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2021/03/11/hello-world/"/>
    <id>http://yoursite.com/2021/03/11/hello-world/</id>
    <published>2021-03-11T12:55:36.407Z</published>
    <updated>2021-03-25T13:01:59.539Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="http://yoursite.com/categories/Web/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
      <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>【Spring】SpringBean生命周期</title>
    <link href="http://yoursite.com/2020/10/22/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/SpringBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://yoursite.com/2020/10/22/Spring学习笔记/SpringBean的生命周期/</id>
    <published>2020-10-22T12:45:31.000Z</published>
    <updated>2023-08-26T08:51:29.364Z</updated>
    
    <content type="html"><![CDATA[<ol><li><strong>注册阶段</strong></li><li><strong>合并阶段</strong></li><li><strong>实例化阶段</strong></li><li><strong>初始化阶段</strong></li><li><strong>销毁阶段</strong></li></ol><p>Bean 的生命周期</p><p>如上图所示，Bean 的生命周期还是比较复杂的，下面来对上图每一个步骤做文字描述:</p><a id="more"></a><p>Spring启动，查找并加载需要被Spring管理的bean，进行Bean的实例化</p><p>Bean实例化后对将Bean的引入和值注入到Bean的属性中</p><p>如果Bean实现了BeanNameAware接口的话，Spring将Bean的Id传递给setBeanName()方法</p><p>如果Bean实现了BeanFactoryAware接口的话，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入</p><p>如果Bean实现了ApplicationContextAware接口的话，Spring将调用Bean的setApplicationContext()方法，将bean所在应用上下文引用传入进来。</p><p>如果Bean实现了BeanPostProcessor接口，Spring就将调用他们的postProcessBeforeInitialization()方法。</p><p>如果bean有被@PostConstruct注解的方法，会执行该方法；如果Bean 实现了InitializingBean接口，Spring将调用他们的afterPropertiesSet()方法。类似的，如果bean使用init-method声明了初始化方法，该方法也会被调用</p><p>如果Bean 实现了BeanPostProcessor接口，Spring就将调用他们的postProcessAfterInitialization()方法。</p><p>此时，Bean已经准备就绪，可以被应用程序使用了。他们将一直驻留在应用上下文中，直到应用上下文被销毁。</p><p>如果bean有被@PreDestroy注解的方法，执行该方法；如果bean实现了DisposableBean接口，Spring将调用它的destory()接口方法，同样，如果bean使用了destory-method 声明销毁方法，该方法也会被调用。</p><p><a href="https://zhuanlan.zhihu.com/p/158468104" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/158468104</a></p><p><a href="https://blog.csdn.net/qq_20021569/article/details/109178816" target="_blank" rel="noopener">https://blog.csdn.net/qq_20021569/article/details/109178816</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;strong&gt;注册阶段&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;合并阶段&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实例化阶段&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;初始化阶段&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;销毁阶段&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Bean 的生命周期&lt;/p&gt;&lt;p&gt;如上图所示，Bean 的生命周期还是比较复杂的，下面来对上图每一个步骤做文字描述:&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>【分布式事务】CAP BASE基本理论及分布式事务解决方案</title>
    <link href="http://yoursite.com/2020/04/20/%E4%B8%AD%E9%97%B4%E4%BB%B6/CAP%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3/"/>
    <id>http://yoursite.com/2020/04/20/中间件/CAP布式事务解决/</id>
    <published>2020-04-20T12:47:48.000Z</published>
    <updated>2023-08-26T09:10:32.058Z</updated>
    
    <content type="html"><![CDATA[<p>多个服务多个库，保持在一个事务中</p><h3 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h3><ul><li>一致性(Consistency)     ： 客户端知道一系列的操作都会同时发生(生效)，所有数据备份，同一时刻有同样的值</li><li>可用性(Availability)     ： 每个操作都必须以可预期的响应结束，一台故障，其他是否可用</li><li>分区容错性(Partition     tolerance) ： 即使出现某个分区无法可用，区间通信失败，但是访问其他分区依然可以完成</li></ul><a id="more"></a><p>具体地讲在分布式系统中，在任何数据库设计中，一个Web应用至多只能同时支持上面的两个属性。显然，任何横向扩展策略都要依赖于数据分区。因此，设计人员必须在一致性与可用性之间做出选择。</p><p>zookeeper CP 需要强一致性</p><p>rocket mq Redis AP</p><p>XA 是一个(2PC)两阶段提交协议，该协议分为以下两个阶段：</p><ul><li>第一阶段：事务协调器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交.</li><li>第二阶段：事务协调器要求每个数据库提交数据。</li></ul><p>其中，如果有任何一个数据库否决此次提交，那么所有数据库都会被要求回滚它们在此事务中的那部分信息。这样做的缺陷是什么呢? 咋看之下我们可以在数据库分区之间获得一致性。</p><p>如果CAP 定理是对的，那么它一定会影响到可用性。</p><p>如果说系统的可用性代表的是执行某项操作相关所有组件的可用性的和。那么在两阶段提交的过程中，可用性就代表了涉及到的每一个数据库中可用性的和。我们假设两阶段提交的过程中每一个数据库都具有99.9%的可用性，那么如果两阶段提交涉及到两个数据库，这个结果就是99.8%。根据系统可用性计算公式，假设每个月43200分钟，99.9%的可用性就是43157分钟, 99.8%的可用性就是43114分钟，相当于每个月的宕机时间增加了43分钟。</p><p><strong>BASE理论</strong></p><p>在分布式系统中，我们往往追求的是可用性，它的重要程序比一致性要高，那么如何实现高可用性呢？ 前人已经给我们提出来了另外一个理论，就是BASE理论，它是用来对CAP定理进行进一步扩充的。BASE理论指的是：</p><ul><li>Basically     Available（基本可用）</li><li>Soft     state（软状态）</li><li>Eventually     consistent（最终一致性）</li></ul><p>理论的核心思想就是：<strong>我们无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性</strong>（Eventual consistency）</p><p>刚性任务：强一致性，遵循ACID </p><p>柔性事务：最寻BASE理论，最终一致性</p><h2 id="分布式事务解决方式："><a href="#分布式事务解决方式：" class="headerlink" title="分布式事务解决方式："></a>分布式事务解决方式：</h2><h3 id="2PC模式，3PC"><a href="#2PC模式，3PC" class="headerlink" title="2PC模式，3PC"></a>2PC模式，3PC</h3><p>1：先对数据库进行预提交的操作，查询是否可以提交，</p><p>2：如果可以提交，就提交数据</p><p>如果有任何一个数据库不可以提交，那么所有的数据库都会回滚</p><h3 id="TCC事务补偿"><a href="#TCC事务补偿" class="headerlink" title="TCC事务补偿"></a>TCC事务补偿</h3><p>Try，与准备数据，准备好了进入下一阶段</p><p>Confirm，确定是否可以提交</p><p>Cancel，如果有任何一个失败，就全部失败</p><p>优点</p><p>用完就释放，不占用资源</p><p>数据最终一致性</p><h3 id="最大努力通知方案"><a href="#最大努力通知方案" class="headerlink" title="最大努力通知方案"></a>最大努力通知方案</h3><p>不保证数据一定能够通知成功，但会提供可查询接口进行核对，结合MQ进行实现</p><h3 id="可靠消息，最终一致性"><a href="#可靠消息，最终一致性" class="headerlink" title="可靠消息，最终一致性"></a>可靠消息，最终一致性</h3><p>业务处理服务在事务提交之前，向实时消息服务请求发送消息，实时消息服务只记录消息，而不真正的发送，业务处理服务在业务事务提交之后，向实时消息服务确认发送，只有得到消息确认发送指令后，实时消息服务才真正发送</p><p>Seata</p><p>远程服务假失败</p><p>远程服务成功，网络故障没有返回</p><p>订单回滚，库存却已经扣减</p><p>远程服务执行完成，后面出现问题，已执行的远程请求不能够回滚</p><h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><p>性能问题：所有参与者在事务提交阶段处于同步阻塞状态，占用链接资源，改进：将提交前和提交后的数据都记录下来，如果需要回滚根据日志回滚</p><p>可靠性问题：如果协调者存在单点故障，提供者一直会处于锁定状态，改进：搭建协调者集群</p><p>数据一致性问题：阶段2中，如果协调者和参与者都挂掉，补偿机制脚本扫描数据是否正确</p><h3 id="消息队列实现分布式事务"><a href="#消息队列实现分布式事务" class="headerlink" title="消息队列实现分布式事务"></a>消息队列实现分布式事务</h3><p>执行业务，插入事件表，返回给用户已完成</p><p>定时任务读取事件表，发送到消息队列，更改事件表状态为已发送</p><p>消费消息，读取事件表，操作业务逻辑，更改事件表状态为已处理</p><p>响应速度快，最终一致性</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;多个服务多个库，保持在一个事务中&lt;/p&gt;&lt;h3 id=&quot;CAP&quot;&gt;&lt;a href=&quot;#CAP&quot; class=&quot;headerlink&quot; title=&quot;CAP&quot;&gt;&lt;/a&gt;CAP&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;一致性(Consistency)     ： 客户端知道一系列的操作都会同时发生(生效)，所有数据备份，同一时刻有同样的值&lt;/li&gt;
&lt;li&gt;可用性(Availability)     ： 每个操作都必须以可预期的响应结束，一台故障，其他是否可用&lt;/li&gt;
&lt;li&gt;分区容错性(Partition     tolerance) ： 即使出现某个分区无法可用，区间通信失败，但是访问其他分区依然可以完成&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【消息队列】消息队列的应用场景和问题</title>
    <link href="http://yoursite.com/2020/03/21/%E4%B8%AD%E9%97%B4%E4%BB%B6/rabbitmq1/"/>
    <id>http://yoursite.com/2020/03/21/中间件/rabbitmq1/</id>
    <published>2020-03-21T12:47:48.000Z</published>
    <updated>2023-08-26T09:11:05.805Z</updated>
    
    <content type="html"><![CDATA[<p>主要的应用场景<br>业务解耦 A将消息写入消息队列，其他需要的系统直接去消息队列中取，后续扩展方便<br>异步处理 将消息写入消息队列，非必要的业务逻辑以异步方式进行运行<br>流量削峰 当并发量大的时，先将消息存入消息队列，系统按照数据库能处理的并发量从消息队列取消息</p><a id="more"></a><h2 id="消息重复消费"><a href="#消息重复消费" class="headerlink" title="消息重复消费"></a>消息重复消费</h2><p>消费者在消费消息之后，会发送一个确认给消息队列，消息队列将该消息删除<br>重复消费主要是因为网络传输问题，使确认信息未返回给消息队列，导致消息重复发送<br>解决方法</p><ol><li>消息做一个唯一主键，重复消费时，主键冲突，数据库chauffeur失败</li><li>做redis的set操作，set操作为幂等操作</li><li>用第三方做消息记录，如redis，给消息分配一个全局id，只要消费过该消息，写入redis。在消费前查询redis里面有没有消费记录</li></ol><h2 id="消息的可靠性传输"><a href="#消息的可靠性传输" class="headerlink" title="消息的可靠性传输"></a>消息的可靠性传输</h2><p>丢数据问题，主要分为生产者丢数据，消息队列丢数据，消费者丢数据</p><ol><li>生产者丢数据<br>rabbitMQ使用transaction和confirm模式<br>transaction机制，发送消息前开启事务，如果过程出错，回滚；成功提交 吞吐量下降<br>confirm机制，当消息发送给消息队列之后，消息队列发送ack给生产者，若没有处理则发送nack</li><li>消息队列丢数据<br>解决方法，开启持久化配置+confirm机制，当消息持久化磁盘之后给生产者发送一个ack信号。如果消息持久化之前，消息队列出问题，生产者自动重发消息<br>开启方法：queue的持久化 durable设置为true，发送消息时将deliveryMode=2</li><li>消费者丢数据<br>产生原因：消费者采用了自动确认消息模式，消费者会自动确认收到的消息，消息队列立即将消息删除，而消费者又传异常没处理该消息，产生消息丢失<br>解决方法：手动确认消息，在处理消息之后发送确认<h2 id="消息的顺序性"><a href="#消息的顺序性" class="headerlink" title="消息的顺序性"></a>消息的顺序性</h2>对需要保证顺序执行的消息，放到同一个消息队列，只使用一个消费者对这个队列进行消费</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要的应用场景&lt;br&gt;业务解耦 A将消息写入消息队列，其他需要的系统直接去消息队列中取，后续扩展方便&lt;br&gt;异步处理 将消息写入消息队列，非必要的业务逻辑以异步方式进行运行&lt;br&gt;流量削峰 当并发量大的时，先将消息存入消息队列，系统按照数据库能处理的并发量从消息队列取消息&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【MySQL】MySQL事务和MVCC机制</title>
    <link href="http://yoursite.com/2020/03/05/%E6%95%B0%E6%8D%AE%E5%BA%93/MVCC/"/>
    <id>http://yoursite.com/2020/03/05/数据库/MVCC/</id>
    <published>2020-03-05T11:38:11.000Z</published>
    <updated>2023-08-26T08:56:10.718Z</updated>
    
    <content type="html"><![CDATA[<p>读不加锁，读写不冲突，通过事务的可见性来保证事务能看到自己应该看到的数据版本</p><p>为了高并发数据库系统中,保证事务与事务之间隔离性和数据一致性,mysql innodb引擎默认是RR的隔离级别,在mysql中通过MVCC快照读和next-key(当前读)两种模式解决幻读问题.</p><a id="more"></a><p>高并发事务</p><p>脏读 不可重复读 幻读 更新丢失</p><p>MVCC 只工作在read committed and repeatable read 两个隔离级别</p><p>undolog多版本链和read view</p><p>RC隔离级别，每次执行select都生成一个read view</p><p>RR隔离级别，第一次执行select时生成一个read view，同一个事务后面的select语句复用第一个read view</p><p>Read uncommitted 总是读取最新的数据行，而不是符合当前事务版本的数据行</p><p>而serializable 则会对所有读取的行都加锁</p><p>InnoDB 的MVCC是通过每行记录后面保存三个隐藏的列来实现 </p><p>6字节的事务ID DB_TRX_ID字段，用来表示最近一次对本行记录做修改的事务id</p><p>7字节的回滚指针DB_ROLL_PTR字段：用来写入回滚段的undo log record</p><p>6字节的DB_ROW_ID字段，一个随着新行插入而单调递增的ID，当由INNODB自动产生聚集索引时，聚集索引会包括这个行ID的值。如果有自己的主键或者合适的唯一索引，那么聚集索引中就不会包含DB_ROW_ID</p><p>MVCC 特点</p><p>每行数据都存在一个版本，每次数据更新时都更新该版本号</p><p>修改时copy 出当前版本，然后随意修改，各个事务之间无干扰</p><p>保存时比较版本号，如果成功commit， 覆盖原纪录，失败则rollback</p><p>INNODB 实现的MVCC 的方式，</p><p>事务以排他锁的方式修改原始数据</p><p>把修改前的数据存放在undolog， 通过回滚指针与主数据关联</p><p>修改成功啥都不做，失败则恢复undo log中的数据</p><p>MVCC + 悲观锁：MVCC解决读写冲突，悲观锁解决写写冲突</p><p>MVCC + 乐观锁：MVCC解决读写冲突，乐观锁解决写写冲突</p><p>什么是MVCC<br>全称Multi-Version Concurrency Control，即多版本并发控制，主要是为了提高数据库的并发性能。以下文章都是围绕InnoDB引擎来讲，因为myIsam不支持事务。</p><p>同一行数据平时发生读写请求时，会上锁阻塞住。但mvcc用更好的方式去处理读—写请求，做到在发生读—写请求冲突时不用加锁。</p><p>这个读是指的快照读，而不是当前读，当前读是一种加锁操作，是悲观锁。</p><p>那它到底是怎么做到读—写不用加锁的，快照读和当前读又是什么鬼，跟着你们的贴心老哥，继续往下看。</p><p>当前读、快照读都是什么鬼<br>什么是MySQL InnoDB下的当前读和快照读？</p><p>当前读<br>它读取的数据库记录，都是当前最新的版本，会对当前读取的数据进行加锁，防止其他事务修改数据。是悲观锁的一种操作。</p><p>如下操作都是当前读：</p><p>select lock in share mode (共享锁)</p><p>select for update (排他锁)</p><p>update (排他锁)</p><p>insert (排他锁)</p><p>delete (排他锁)</p><p>串行化事务隔离级别</p><p>快照读<br>快照读的实现是基于多版本并发控制，即MVCC，既然是多版本，那么快照读读到的数据不一定是当前最新的数据，有可能是之前历史版本的数据。</p><p>如下操作是快照读：</p><p>不加锁的select操作（注：事务级别不是串行化）<br>快照读与mvcc的关系<br>MVCCC是“维持一个数据的多个版本，使读写操作没有冲突”的一个抽象概念。</p><p>这个概念需要具体功能去实现，这个具体实现就是快照读。（具体实现下面讲）</p><p>听完贴心老哥的讲解，是不是瞬间茅厕顿开。</p><p>数据库并发场景<br>读-读：不存在任何问题，也不需要并发控制</p><p>读-写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读</p><p>写-写：有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失</p><p>MVCC解决并发哪些问题？<br>mvcc用来解决读—写冲突的无锁并发控制，就是为事务分配单向增长的时间戳。为每个数据修改保存一个版本，版本与事务时间戳相关联。</p><p>读操作只读取该事务开始前的数据库快照。</p><p>解决问题如下：</p><p>并发读-写时：可以做到读操作不阻塞写操作，同时写操作也不会阻塞读操作。</p><p>解决脏读、幻读、不可重复读等事务隔离问题，但不能解决上面的写-写 更新丢失问题。</p><p>因此有了下面提高并发性能的组合拳：</p><p>MVCC + 悲观锁：MVCC解决读写冲突，悲观锁解决写写冲突</p><p>MVCC + 乐观锁：MVCC解决读写冲突，乐观锁解决写写冲突</p><p>MVCC的实现原理<br>它的实现原理主要是版本链，undo日志 ，Read View 来实现的</p><p>版本链<br>我们数据库中的每行数据，除了我们肉眼看见的数据，还有几个隐藏字段，得开天眼才能看到。分别是db_trx_id、db_roll_pointer、db_row_id。</p><p>db_trx_id</p><p>6byte，最近修改(修改/插入)事务ID：记录创建这条记录/最后一次修改该记录的事务ID。</p><p>db_roll_pointer（版本链关键）</p><p>7byte，回滚指针，指向这条记录的上一个版本（存储于rollback segment里）</p><p>db_row_id</p><p>6byte，隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以db_row_id产生一个聚簇索引。</p><p>实际还有一个删除flag隐藏字段, 记录被更新或删除并不代表真的删除，而是删除flag变了</p><p>如上图，db_row_id是数据库默认为该行记录生成的唯一隐式主键，db_trx_id是当前操作该记录的事务ID，而db_roll_pointer是一个回滚指针，用于配合undo日志，指向上一个旧版本。</p><p>每次对数据库记录进行改动，都会记录一条undo日志，每条undo日志也都有一个roll_pointer属性（INSERT操作对应的undo日志没有该属性，因为该记录并没有更早的版本），可以将这些undo日志都连起来，串成一个链表，所以现在的情况就像下图一样：</p><p>对该记录每次更新后，都会将旧值放到一条undo日志中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被roll_pointer属性连接成一个链表，我们把这个链表称之为版本链，版本链的头节点就是当前记录最新的值。另外，每个版本中还包含生成该版本时对应的事务id，这个信息很重要，在根据ReadView判断版本可见性的时候会用到。</p><p>undo日志<br>Undo log 主要用于记录数据被修改之前的日志，在表信息修改之前先会把数据拷贝到undo log里。</p><p>当事务进行回滚时可以通过undo log 里的日志进行数据还原。</p><p>Undo log 的用途</p><p>保证事务进行rollback时的原子性和一致性，当事务进行回滚的时候可以用undo log的数据进行恢复。</p><p>用于MVCC快照读的数据，在MVCC多版本控制中，通过读取undo log的历史版本数据可以实现不同事务版本号都拥有自己独立的快照数据版本。</p><p>undo log主要分为两种：</p><p>insert undo log</p><p>代表事务在insert新记录时产生的undo log , 只在事务回滚时需要，并且在事务提交后可以被立即丢弃</p><p>update undo log（主要）</p><p>事务在进行update或delete时产生的undo log ; 不仅在事务回滚时需要，在快照读时也需要；</p><p>所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被purge线程统一清除</p><p>Read View(读视图)<br>事务进行快照读操作的时候生产的读视图(Read View)，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照。</p><p>记录并维护系统当前活跃事务的ID(没有commit，当每个事务开启时，都会被分配一个ID, 这个ID是递增的，所以越新的事务，ID值越大)，是系统中当前不应该被本事务看到的其他事务id列表。</p><p>Read View主要是用来做可见性判断的, 即当我们某个事务执行快照读的时候，对该记录创建一个Read View读视图，把它比作条件用来判断当前事务能够看到哪个版本的数据，既可能是当前最新的数据，也有可能是该行记录的undo log里面的某个版本的数据。</p><p>Read View几个属性</p><p>trx_ids: 当前系统活跃(未提交)事务版本号集合。</p><p>min_limit_id: 创建当前read view 时“当前系统最大事务版本号+1”。</p><p>max_limit_id: 创建当前read view 时“系统正处于活跃事务最小版本号”</p><p>creator_trx_id: 创建当前read view的事务版本号；</p><p>Read View可见性判断条件</p><p>db_trx_id &lt; max_limit_id || db_trx_id == creator_trx_id（显示）</p><p>如果数据事务ID小于read view中的最小活跃事务ID，则可以肯定该数据是在当前事务启之前就已经存在了的,所以可以显示。</p><p>或者数据的事务ID等于creator_trx_id ，那么说明这个数据就是当前事务自己生成的，自己生成的数据自己当然能看见，所以这种情况下此数据也是可以显示的。</p><p>db_trx_id &gt;= min_limit_id（不显示）</p><p>如果数据事务ID大于read view 中的当前系统的最大事务ID，则说明该数据是在当前read view 创建之后才产生的，所以数据不显示。如果小于则进入下一个判断</p><p>db_trx_id是否在活跃事务（trx_ids）中</p><p>不存在：则说明read view产生的时候事务已经commit了，这种情况数据则可以显示。</p><p>已存在：则代表我Read View生成时刻，你这个事务还在活跃，还没有Commit，你修改的数据，我当前事务也是看不见的。</p><p>MVCC和事务隔离级别<br>上面所讲的Read View用于支持RC（Read Committed，读提交）和RR（Repeatable Read，可重复读）隔离级别的实现。</p><p>RR、RC生成时机<br>RC隔离级别下，是每个快照读都会生成并获取最新的Read View；</p><p>而在RR隔离级别下，则是同一个事务中的第一个快照读才会创建Read View, 之后的快照读获取的都是同一个Read View，之后的查询就不会重复生成了，所以一个事务的查询结果每次都是一样的。</p><p>解决幻读问题</p><p>快照读：通过MVCC来进行控制的，不用加锁。按照MVCC中规定的“语法”进行增删改查等操作，以避免幻读。</p><p>当前读：通过next-key锁（行锁+gap锁）来解决问题的。</p><p>RC、RR级别下的InnoDB快照读区别<br>在RR级别下的某个事务的对某条记录的第一次快照读会创建一个快照及Read View， 将当前系统活跃的其他事务记录起来，此后在调用快照读的时候，还是使用的是同一个Read View，所以只要当前事务在其他事务提交更新之前使用过快照读，那么之后的快照读使用的都是同一个Read View，所以对之后的修改不可见；</p><p>即RR级别下，快照读生成Read View时，Read View会记录此时所有其他活动事务的快照，这些事务的修改对于当前事务都是不可见的。而早于Read View创建的事务所做的修改均是可见</p><p>而在RC级别下的，事务中，每次快照读都会新生成一个快照和Read View, 这就是我们在RC级别下的事务中可以看到别的事务提交的更新的原因</p><p>总结<br>从以上的描述中我们可以看出来，所谓的MVCC指的就是在使用READ COMMITTD、REPEATABLE READ这两种隔离级别的事务在执行普通的SEELCT操作时访问记录的版本链的过程，这样子可以使不同事务的读-写、写-读操作并发执行，从而提升系统性能。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;读不加锁，读写不冲突，通过事务的可见性来保证事务能看到自己应该看到的数据版本&lt;/p&gt;&lt;p&gt;为了高并发数据库系统中,保证事务与事务之间隔离性和数据一致性,mysql innodb引擎默认是RR的隔离级别,在mysql中通过MVCC快照读和next-key(当前读)两种模式解决幻读问题.&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>【K8s】搭建k8s 遇到的问题 failed to pull image k8s.gcr.io/kube-apiserver:v1.19.3:output:Error response from daemon</title>
    <link href="http://yoursite.com/2020/01/02/K8s/K8sPullImageBug/"/>
    <id>http://yoursite.com/2020/01/02/K8s/K8sPullImageBug/</id>
    <published>2020-01-02T12:45:31.000Z</published>
    <updated>2023-08-26T08:41:48.489Z</updated>
    
    <content type="html"><![CDATA[<p>无法使用下载k8s镜像的解决办法</p><p>[ERROR ImagePull]: failed to pull image k8s.gcr.io/kube-apiserver:v1.19.3: output: Error response from daemon: Get <a href="https://k8s.gcr.io/v2/" target="_blank" rel="noopener">https://k8s.gcr.io/v2/</a>: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)<br>, error: exit status 1<br>    [ERROR ImagePull]: failed to pull image k8s.gcr.io/kube-controller-manager:v1.19.3: output: Error response from daemon: Get <a href="https://k8s.gcr.io/v2/" target="_blank" rel="noopener">https://k8s.gcr.io/v2/</a>: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)<br>, error: exit status 1<br>    [ERROR ImagePull]: failed to pull image k8s.gcr.io/kube-scheduler:v1.19.3: output: Error response from daemon: Get <a href="https://k8s.gcr.io/v2/" target="_blank" rel="noopener">https://k8s.gcr.io/v2/</a>: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)<br>, error: exit status 1</p><a id="more"></a><blockquote><p>根据缺失的image创建如下的shell 脚本 pull_image.sh ，并运行sh pull_image.sh</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">images=(</span><br><span class="line">    kube-apiserver:v1.19.3</span><br><span class="line">    kube-controller-manager:v1.19.3</span><br><span class="line">    kube-scheduler:v1.19.3</span><br><span class="line">    kube-proxy:v1.19.3</span><br><span class="line">    pause:3.2</span><br><span class="line">    etcd:3.4.13-0</span><br><span class="line">    coredns:1.7.0</span><br><span class="line">)</span><br><span class="line">for imageName in $&#123;images[@]&#125; ; do</span><br><span class="line">        docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/$&#123;imageName&#125;</span><br><span class="line">        docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/$&#123;imageName&#125; k8s.gcr.io/$&#123;imageName&#125;</span><br><span class="line">        docker rmi registry.cn-hangzhou.aliyuncs.com/google_containers/$&#123;imageName&#125;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;无法使用下载k8s镜像的解决办法&lt;/p&gt;&lt;p&gt;[ERROR ImagePull]: failed to pull image k8s.gcr.io/kube-apiserver:v1.19.3: output: Error response from daemon: Get &lt;a href=&quot;https://k8s.gcr.io/v2/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://k8s.gcr.io/v2/&lt;/a&gt;: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)&lt;br&gt;, error: exit status 1&lt;br&gt;    [ERROR ImagePull]: failed to pull image k8s.gcr.io/kube-controller-manager:v1.19.3: output: Error response from daemon: Get &lt;a href=&quot;https://k8s.gcr.io/v2/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://k8s.gcr.io/v2/&lt;/a&gt;: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)&lt;br&gt;, error: exit status 1&lt;br&gt;    [ERROR ImagePull]: failed to pull image k8s.gcr.io/kube-scheduler:v1.19.3: output: Error response from daemon: Get &lt;a href=&quot;https://k8s.gcr.io/v2/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://k8s.gcr.io/v2/&lt;/a&gt;: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)&lt;br&gt;, error: exit status 1&lt;/p&gt;
    
    </summary>
    
      <category term="K8s" scheme="http://yoursite.com/categories/K8s/"/>
    
    
      <category term="K8s" scheme="http://yoursite.com/tags/K8s/"/>
    
  </entry>
  
  <entry>
    <title>Docker的基本使用</title>
    <link href="http://yoursite.com/2019/12/26/Docker/docker-use/"/>
    <id>http://yoursite.com/2019/12/26/Docker/docker-use/</id>
    <published>2019-12-26T12:47:48.000Z</published>
    <updated>2020-11-28T08:39:11.658Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Docker使用"><a href="#Docker使用" class="headerlink" title="Docker使用"></a>Docker使用</h2><p>不建议使用windows系统进行docker使用，建议使用linux</p><p>首先安装好linux(版本不要太低)，我用的centos(minimal)和ubuntu</p><a id="more"></a><p>主要是网络问题 一定要记得把自己电脑的vm net service服务开启</p><p><img src="C:\Users\fx50jk\AppData\Roaming\Typora\typora-user-images\1570509986619.png" alt="1570509986619"></p><p>安装好之后使用Xshell进行连接，ubuntu要看下ssh是否可用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ps -e |grep ssh  //查看ssh服务是否有</span><br><span class="line">//如果没有安装</span><br><span class="line">apt-get install ssh</span><br><span class="line">service ssh start</span><br></pre></td></tr></table></figure><p>ubuntu root账户不能直连的问题</p><p>修改/etc/ssh/sshd_config</p><p><img src="C:\Users\fx50jk\AppData\Roaming\Typora\typora-user-images\1570519883408.png" alt="1570519883408"></p><p>然后 /etc/init.d/ssh restart 启动ssh 服务</p><p>OK，现在开始安装docker了</p><p>yum install docker</p><p>docker 默认镜像pull的很慢 我使用了阿里云的镜像加速</p><p>需要去阿里云找镜像加速器</p><p><img src="C:\Users\fx50jk\AppData\Roaming\Typora\typora-user-images\1570510916443.png" alt="1570510916443"></p><p><img src="C:\Users\fx50jk\AppData\Roaming\Typora\typora-user-images\1570510619481.png" alt="1570510619481"></p><p>接下来安装软件</p><p>docker search 查看安装软件的源</p><p>docker pull mysql 默认为最新的  </p><p>docker pull mysql:5.7指定版本</p><p>systemctl daemon-reload</p><p>systemctl start docker</p><p>docker start $(docker ps -a -q)</p><p>查看latest镜像的具体版本</p><p>docker image inspect (docker image名称):latest|grep -i version</p><p>为运行中的容器添加映射端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`iptables -t nat -A DOCKER -p tcp --dport 8001 -j DNAT --to-destination 172.17.0.19:800012`</span><br></pre></td></tr></table></figure><ol><li>提交一个运行中的容器为镜像，docker commit -m ’addimages‘ mycentos jcy/mycentos:v1 </li><li>运行镜像并添加端口docker run -d -p 8000:80 jcy/mycentos:v1 /bin/bash </li></ol><p>运行容器</p><p>docker run -d -i -t centos:7 /bin/bash</p><p>进入容器</p><p> docker exec -it logstash /bin/bash </p><p> docker attach  containerId   如果进入后使用exit 会将容器关闭</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost home]# docker run -itd --name=centos7_base centos:7 /bin/bash</span><br><span class="line">8aebcca487a8e71ec8a5693bb2160170f33e091f9df2c8053937a6821ef50c51</span><br><span class="line">[root@localhost home]# docker ps </span><br><span class="line">CONTAINER ID        IMAGE                  COMMAND                  CREATED             STATUS              PORTS                                                  NAMES</span><br><span class="line">8aebcca487a8        centos:7               "/bin/bash"              3 seconds ago       Up 3 seconds                                                               centos7_base</span><br><span class="line">d6d8c141590a        logstash:latest        "/docker-entrypoin..."   15 hours ago        Up 15 hours         0.0.0.0:4560-&gt;4560/tcp                                 logstash</span><br><span class="line">60839b634981        kibana:latest          "/docker-entrypoin..."   15 hours ago        Up 15 hours         0.0.0.0:5601-&gt;5601/tcp                                 kibana</span><br><span class="line">e0791cc7e67c        elasticsearch:latest   "/docker-entrypoin..."   15 hours ago        Up 15 hours         0.0.0.0:9200-&gt;9200/tcp, 0.0.0.0:9300-&gt;9300/tcp         elasticsearch</span><br><span class="line">43d1110fe66e        zookeeper              "/docker-entrypoin..."   13 months ago       Up 16 hours         2888/tcp, 3888/tcp, 0.0.0.0:2181-&gt;2181/tcp, 8080/tcp   myzk1</span><br><span class="line">[root@localhost home]# docker exec -it centos7_base /bin/bash</span><br></pre></td></tr></table></figure><p>gem 替换源</p><p>gem sources –add <a href="https://gems.ruby-china.com/" target="_blank" rel="noopener">https://gems.ruby-china.com/</a> –remove <a href="https://rubygems.org/" target="_blank" rel="noopener">https://rubygems.org/</a></p><p><a href="https://blog.csdn.net/ke369093457/article/details/89678402" target="_blank" rel="noopener">https://blog.csdn.net/ke369093457/article/details/89678402</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Docker使用&quot;&gt;&lt;a href=&quot;#Docker使用&quot; class=&quot;headerlink&quot; title=&quot;Docker使用&quot;&gt;&lt;/a&gt;Docker使用&lt;/h2&gt;&lt;p&gt;不建议使用windows系统进行docker使用，建议使用linux&lt;/p&gt;&lt;p&gt;首先安装好linux(版本不要太低)，我用的centos(minimal)和ubuntu&lt;/p&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis Invalid bound statement (not found)</title>
    <link href="http://yoursite.com/2019/12/20/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/xml/"/>
    <id>http://yoursite.com/2019/12/20/Spring学习笔记/xml/</id>
    <published>2019-12-20T08:01:23.000Z</published>
    <updated>2022-02-27T14:28:06.757Z</updated>
    
    <content type="html"><![CDATA[<p>已经在yml配置过了对应的location,但是还是出现Invalid bound statement not found<br>问题：<br>在resources下默认以com.msy.mall.dao建出来的默认是文件夹(名字为com.msy.mall.dao)，编译完成之后是会创建一个com.msy.mall.dao的文件夹<br>在建folder时以com/msy/mall/dao 建出来的才是包，编译之后xml才会在对应的dao</p><a id="more"></a><p><img src="/images/InvalidBoundStatementNotFound.png" alt="InvalidBoundStatementNotFound"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;已经在yml配置过了对应的location,但是还是出现Invalid bound statement not found&lt;br&gt;问题：&lt;br&gt;在resources下默认以com.msy.mall.dao建出来的默认是文件夹(名字为com.msy.mall.dao)，编译完成之后是会创建一个com.msy.mall.dao的文件夹&lt;br&gt;在建folder时以com/msy/mall/dao 建出来的才是包，编译之后xml才会在对应的dao&lt;/p&gt;
    
    </summary>
    
    
      <category term="Mybatis" scheme="http://yoursite.com/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>【Java】JDK1.8新特性</title>
    <link href="http://yoursite.com/2019/10/27/Java%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/Java1.8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://yoursite.com/2019/10/27/Java基本知识/Java1.8新特性/</id>
    <published>2019-10-27T13:24:27.000Z</published>
    <updated>2019-11-04T13:15:50.558Z</updated>
    
    <content type="html"><![CDATA[<p>JDK1.8新特性<a id="more"></a></p><h2 id="接口可以有默认方法和静态方法"><a href="#接口可以有默认方法和静态方法" class="headerlink" title="接口可以有默认方法和静态方法"></a>接口可以有默认方法和静态方法</h2><p>默认方法，可以往现存接口中添加新的方法，不强制那些实现了该接口的类也同时实现这个方法，不改变原有的继承体系，改进接口如java.util.Collection 接口添加新方法，如 stream() 、parallelStream() 、 forEach() 和 removeIf()</p><p>静态方法，已经实现的方法，把常用的工具方法写在接口上</p><p>当一个类实现两个接口有同名函数</p><blockquote><p>如果方法具有相同的请求参数和返回值，则视为一个方法<br>如果方法有不同的请求参数，就视为两个方法<br>如果方法有相同的请求参数，不同的返回值，则编译出错</p></blockquote><h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><p>不需要匿名对象，直接使用lambda实现匿名表达式Collections.sort(arr,(a,b)-&gt;b.compareTo(a));不需要写参数类型，可以自动推断</p><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>指仅包含一个抽象方法的接口，每一个类型的lambda表达式都对应一个抽象方法接口，每一个该类型的lambda表达式就会匹配这个抽象方法。</p><h2 id="Optional接口"><a href="#Optional接口" class="headerlink" title="Optional接口"></a>Optional接口</h2><p>防止空指针异常的辅助类型，Optional被定义为一个容器，可为null或者不是null<br>可作为返回类型，如果类型实例有值就返回值，没有值则使用替代行为<br>不是Serializable，不适合作为类的字段</p><h2 id="Stream接口"><a href="#Stream接口" class="headerlink" title="Stream接口"></a>Stream接口</h2><p>Stream，Collections里面的<br>只能对List或者Set创建Stream对象<br>类似于迭代器Iterator，单向，不可往复，数据只遍历一次，对集合中的元素进行筛选过滤，排序，修改</p><h2 id="新的Date接口"><a href="#新的Date接口" class="headerlink" title="新的Date接口"></a>新的Date接口</h2><p>LocalDate，LocalTime，LocalDateTime，都是不可变的<br>DateTimeFormatter线程安全的，原来的SimpleDateFormat不是线程安全的</p><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/" target="_blank" rel="noopener">JDK1.8 Stream的使用</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JDK1.8新特性
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【Java】并发工具类CyclicBarrier、CountDownLatch、Semaphore、Exchanger、Phaser</title>
    <link href="http://yoursite.com/2019/10/23/Java%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/Java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>http://yoursite.com/2019/10/23/Java基本知识/Java并发工具类/</id>
    <published>2019-10-23T08:46:03.000Z</published>
    <updated>2019-11-01T05:54:17.808Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="CyclicBarrier，循环栅栏"><a href="#CyclicBarrier，循环栅栏" class="headerlink" title="CyclicBarrier，循环栅栏"></a>CyclicBarrier，循环栅栏</h2><p>允许让一组线程进行相互等待await()，直到达到公共屏障点，才会将阻塞的这些线程释放并通过先调用barrierAction，然后让他们一起继续工作，在释放线程之后可以重用。</p><a id="more"></a><p>内部主要使用重入锁ReentrantLock和Condition实现<br>构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line"><span class="comment">//通过传入Runnable，当达到屏障时先执行barrierAction</span></span><br><span class="line"><span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="keyword">this</span>.count = parties;</span><br><span class="line">    <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要方法：<br>//等到所有的线程都到达指定的临界点<br>await() throws InterruptedException, BrokenBarrierException </p><p>//与上面的await方法功能基本一致，只不过这里有超时限制，阻塞等待直至到达超时时间为止<br>await(long timeout, TimeUnit unit) throws InterruptedException,<br>BrokenBarrierException, TimeoutException </p><p>//获取当前有多少个线程阻塞等待在临界点上<br>int getNumberWaiting()</p><p>//用于查询阻塞等待的线程是否被中断<br>boolean isBroken()</p><p>//将屏障重置为初始状态。如果当前有线程正在临界点等待的话，将抛出BrokenBarrierException。<br>void reset()</p><p>当出现异常时使用breakBarrier()终止所有线程</p><h2 id="CountDownLatch，倒计时器"><a href="#CountDownLatch，倒计时器" class="headerlink" title="CountDownLatch，倒计时器"></a>CountDownLatch，倒计时器</h2><p>让一个或多个线程等待其他若干个线程执行完，当计数器为0时，所有等待的线程才可以继续执行，无法被重置</p><p>通过共享锁Sync实现，需要传入一个int参数，指定要多少线程执行完，才让等待的线程执行</p><p>构造函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>内部方法：</p><ol><li>await() throws InterruptedException：调用该方法的线程等到构造方法传入的N减到0的时候，才能继续往下执行；</li><li>await(long timeout, TimeUnit unit)：与上面的await方法功能一致，只不过这里有了时间限制，调用该方法的线程等到指定的timeout时间后，不管N是否减至为0，都会继续往下执行；</li><li>countDown()：使CountDownLatch初始值N减1；</li><li>long getCount()：获取当前CountDownLatch维护的值；</li></ol><h2 id="Semaphore，信号量"><a href="#Semaphore，信号量" class="headerlink" title="Semaphore，信号量"></a>Semaphore，信号量</h2><p>限制可以访问某些资源的线程数目<br>默认为非公平锁，可通过构造函数指定公平性，当semaphore=1，可以当做是一个互斥锁使用<br>=1，其他线程可以获取<br>=0，排他，其他线程阻塞<br>构造函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>内部主要方法：<br>acquire(); 获取许可，信号量-1；当信号量&gt;0，可以获取，若信号量=0，阻塞<br>release(); 释放许可，信号量+1</p><h2 id="Exchanger，交换器"><a href="#Exchanger，交换器" class="headerlink" title="Exchanger，交换器"></a>Exchanger，交换器</h2><p>允许在并发任务之间交换数据。<br>通过定义两个线程之间的同步点，当两个线程都达到同步点时，交换数据<br>在Exchanger中，如果一个线程已经到达了exchanger节点时，对于它的伙伴节点的情况有三种：</p><ol><li>如果它的伙伴节点在该线程到达之前已经调用了exchanger方法，则它会唤醒它的伙伴然后进行数据交换，得到各自数据返回。</li><li>如果它的伙伴节点还没有到达交换点，则该线程将会被挂起，等待它的伙伴节点到达被唤醒，完成数据交换。</li><li>如果当前线程被中断了则抛出异常，或者等待超时了，则抛出超时异常。</li></ol><h2 id="Phaser，阶段器"><a href="#Phaser，阶段器" class="headerlink" title="Phaser，阶段器"></a>Phaser，阶段器</h2><p>进行并发阶段任务运行，一个任务分为多个阶段，每个阶段完成之后才能进行下一阶段的运行<br>phase就是阶段，初值为0，当所有的线程执行完当前阶段任务已结束，进入到下一阶段任务，phase的值自动加1。<br>parties就是线程， parties=4就意味着Phaser对象当前管理着4个线程。</p><p>主要方法：<br>register()，动态的添加一个或多个线程<br>int arriveAndAwaitAdvance()，相当于await()方法，记录到达线程数，阻塞等待其他线程到达同步点后再继续执行。<br>arriveAndDeregister()，动态的撤销线程的注册，该线程已结束，不再参与后续的阶段<br>boolean onAdvance(int phase,int register)，当每一阶段结束调用该方法，  默认是所有线程都撤销注册为止，return true，阶段停止，可重写该方法设置自定义阶段响应。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onAdvance</span><span class="params">(<span class="keyword">int</span> phase, <span class="keyword">int</span> registeredParties)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> registeredParties == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>Java并发编程艺术 方腾飞<br>Java并发编程实战  Brian Goetz / Tim Peierls / Joshua Bloch / Joseph Bowbeer / David Holmes / Doug Lea</p><p><a href="https://juejin.im/post/5aeec3ebf265da0ba76fa327" target="_blank" rel="noopener">大白话说java并发工具类-CountDownLatch，CyclicBarrier</a><br><a href="http://cmsblogs.com/?p=2263" target="_blank" rel="noopener">死磕Java并发</a><br><a href="https://blog.csdn.net/zhm1563550235/article/details/84453906" target="_blank" rel="noopener">Java并发——Phaser “阶段器”</a></p>]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;h2 id=&quot;CyclicBarrier，循环栅栏&quot;&gt;&lt;a href=&quot;#CyclicBarrier，循环栅栏&quot; class=&quot;headerlink&quot; title=&quot;CyclicBarrier，循环栅栏&quot;&gt;&lt;/a&gt;CyclicBarrier，循环栅栏&lt;/h2&gt;&lt;p&gt;允许让一组线程进行相互等待await()，直到达到公共屏障点，才会将阻塞的这些线程释放并通过先调用barrierAction，然后让他们一起继续工作，在释放线程之后可以重用。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【Spring】Spring中的事务的属性、隔离级别、传播机制</title>
    <link href="http://yoursite.com/2019/10/22/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/spring-transactional/"/>
    <id>http://yoursite.com/2019/10/22/Spring学习笔记/spring-transactional/</id>
    <published>2019-10-22T12:45:31.000Z</published>
    <updated>2023-05-16T15:50:35.823Z</updated>
    
    <content type="html"><![CDATA[<p>Spring的事务管理分为编程式事务和声明式事务两种。<a id="more"></a><br>编程式事务：通过编码方式TransactionTemplate或者直接使用底层的PlatformTransactionManager实现事务控制<br>声明式事务：基于AOP，通过XML或注解@Transactional实现，将业务逻辑和事务处理解耦</p><p>Spring的默认事务处理只能进行回滚运行时、未检查的异常或者Error<br>并且默认只能用到public方法(AOP的JDK动态代理问题，下文解释)</p><h2 id="Transactional注解属性说明"><a href="#Transactional注解属性说明" class="headerlink" title="@Transactional注解属性说明"></a>@Transactional注解属性说明</h2><table><thead><tr><th>属性名</th><th>说明</th></tr></thead><tbody><tr><td>name</td><td>当在配置文件中有多个 TransactionManager , 可以用该属性指定选择哪个事务管理器。</td></tr><tr><td>propagation</td><td>事务的传播行为，默认值为 REQUIRED。</td></tr><tr><td>isolation</td><td>事务的隔离度，默认值采用 DEFAULT。</td></tr><tr><td>timeout</td><td>事务的超时时间，默认值为-1。如果超过该时间限制但事务还没有完成，则自动回滚事务。</td></tr><tr><td>read-only</td><td>指定事务是否为只读事务，默认值为 false；为了忽略那些不需要事务的方法，比如读取数据，可以设置 read-only 为 true。</td></tr><tr><td>rollback-for</td><td>用于指定能够触发事务回滚的异常类型，如果有多个异常类型需要指定，各类型之间可以通过逗号分隔。</td></tr><tr><td>no-rollback- for</td><td>抛出 no-rollback-for 指定的异常类型，不回滚事务。</td></tr></tbody></table><h3 id="propagation属性"><a href="#propagation属性" class="headerlink" title="propagation属性"></a>propagation属性</h3><p>指定事务的传播方式，默认为REQUIRED</p><table><thead><tr><th>名称</th><th>解释</th></tr></thead><tbody><tr><td>Propagation.REQUIRED</td><td>如果当前存在事务，则加入该事务，如果当前不存在事务，则创建一个新的事务。</td></tr><tr><td>Propagation.NESTED</td><td>和 Propagation.REQUIRED 效果一样。</td></tr><tr><td>Propagation.MANDATORY</td><td>如果当前存在事务，则加入该事务；如果当前不存在事务，则抛出异常。</td></tr><tr><td>Propagation.REQUIRES_NEW</td><td>重新创建一个新的事务，如果当前存在事务，暂停当前的事务。</td></tr><tr><td>Propagation.NOT_SUPPORTED</td><td>以非事务的方式运行，如果当前存在事务，暂停当前的事务。</td></tr><tr><td>Propagation.SUPPORTS</td><td>如果当前存在事务，则加入该事务；如果当前不存在事务，则以非事务的方式继续运行。</td></tr><tr><td>Propagation.NEVER</td><td>以非事务的方式运行，如果当前存在事务，则抛出异常。</td></tr></tbody></table><h3 id="isolation属性"><a href="#isolation属性" class="headerlink" title="isolation属性"></a>isolation属性</h3><p>隔离级别是指若干个并发的事务之间的隔离程度。<br>TransactionDefinition 接口中定义了五个表示隔离级别的常量：</p><table><thead><tr><th>值</th><th>解释</th></tr></thead><tbody><tr><td>TransactionDefinition.ISOLATION_DEFAULT</td><td>默认值，表示使用底层数据库的默认隔离级别。对大部分数据库而言，通常这值就是ISOLATION_READ_COMMITTED。</td></tr><tr><td>TransactionDefinition.ISOLATION_READ_COMMITTED</td><td>该隔离级别表示一个事务只能读取另一个事务已经提交的数据。该级别可以防止脏读，这也是大多数情况下的推荐值。</td></tr><tr><td>TransactionDefinition.ISOLATION_READ_UNCOMMITTED</td><td>该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据。该级别不能防止脏读和不可重复读，因此很少使用该隔离级别。</td></tr><tr><td>TransactionDefinition.ISOLATION_REPEATABLE_READ</td><td>该隔离级别表示一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同。即使在多次查询之间有新增的数据满足该查询，这些新增的记录也会被忽略。该级别可以防止脏读和不可重复读。</td></tr><tr><td>TransactionDefinition.ISOLATION_SERIALIZABLE</td><td>串行化，所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</td></tr></tbody></table><h3 id="rollbackfor属性"><a href="#rollbackfor属性" class="headerlink" title="rollbackfor属性"></a>rollbackfor属性</h3><p>默认情况下，如果在事务中抛出了未检查异常（继承自 RuntimeException 的异常）或者 Error，则 Spring 将回滚事务；除此之外，Spring 不会回滚事务。</p><p>如果在事务中抛出其他类型的异常，并期望 Spring 能够回滚事务，可以指定 rollbackFor。例：<br>@Transactional(propagation= Propagation.REQUIRED,rollbackFor= MyException.class)</p><p>通过分析 Spring 源码可以知道，若在目标方法中抛出的异常是 rollbackFor 指定的异常的子类，事务同样会回滚。</p><h2 id="Spring中事务的实现机制"><a href="#Spring中事务的实现机制" class="headerlink" title="Spring中事务的实现机制"></a>Spring中事务的实现机制</h2><p>当应用系统调用声明了 @Transactional 的目标方法时，Spring Framework 默认使用 AOP 代理，在代码运行时生成一个代理对象，根据 @Transactional 的属性配置信息，这个代理对象决定该声明 @Transactional 的目标方法是否由拦截器 TransactionInterceptor 来使用拦截，在 TransactionInterceptor 拦截时，会在目标方法开始执行之前创建并加入事务，并执行目标方法的逻辑, 最后根据执行情况是否出现异常，利用抽象事务管理器 AbstractPlatformTransactionManager 操作数据源 DataSource 提交或回滚事务。</p><p>Spring AOP 代理有 CglibAopProxy 和 JdkDynamicAopProxy 两种，以 CglibAopProxy 为例，对于 CglibAopProxy，需要调用其内部类的 DynamicAdvisedInterceptor 的 intercept 方法。对于 JdkDynamicAopProxy，需要调用其 invoke 方法。</p><p>事务管理的框架是由抽象事务管理器 AbstractPlatformTransactionManager 来提供的，而具体的底层事务处理实现，由 PlatformTransactionManager 的具体实现类来实现，如事务管理器 DataSourceTransactionManager。不同的事务管理器管理不同的数据资源 DataSource，比如 DataSourceTransactionManager 管理 JDBC 的 Connection。</p><p><img src="/images/Spring-transaction-mechanism.png" alt="1570411257098"></p><h2 id="Transational-为什么只能使public方法有效"><a href="#Transational-为什么只能使public方法有效" class="headerlink" title="@Transational 为什么只能使public方法有效"></a>@Transational 为什么只能使public方法有效</h2><p>在使用注解@Transactional时，Spring默认使用AOP代理，在代码运行时生成代理对象，通过TransactionInterceptor 在目标方法执行前后进行拦截之前，DynamicAdvisedInterceptor（CglibAopProxy 的内部类）的 intercept 方法或 JdkDynamicAopProxy 的 invoke 方法会间接调用 AbstractFallbackTransactionAttributeSource（Spring 通过这个类获取@Transactional 注解的事务属性配置属性信息）的 computeTransactionAttribute 方法，这个方法会检查方法是否为public，若不是则不会获取@Transactional的属性配置信息，造成TransactionInterceptor不会去拦截该目标方法进行事务管理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> TransactionAttribute <span class="title">computeTransactionAttribute</span><span class="params">(Method method,Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Don't allow no-public methods as required           </span></span><br><span class="line"><span class="keyword">if</span>(allowPublicMethodsOnly()&amp;&amp;!Modifier.isPublic(method.getModifiers())&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Transactional-注解失效的情况"><a href="#Transactional-注解失效的情况" class="headerlink" title="Transactional 注解失效的情况"></a>Transactional 注解失效的情况</h2><ol><li><p>非public方法修饰的方法</p><p>原因： 事务是基于AOP动态代理实现的，如果类或者方法的修饰符不是public，@Transactional 注解就不会对Bean或者方法进行代理调用。底层实现会去比较TransactionalAttribute，如果是public 会返回null</p><p>在动态代理对象，进行代理调用时，会获取当前需要执行方法适配的AOP逻辑（DynamicAdvisedInceptor）</p><p>static 修饰的方法也会导致事务失效</p><p>原因： 静态方法是类级别的，调用需要知道类信息，而类信息在编译器就已经知道了，并不支持在运行期的动态绑定。</p></li><li><p>一个没有事务的方法调用一个有事务的方法，事务会被忽略</p><p>原因：在类内部调用类内部的事务方法时并不是通过代理对象来调用的，而是通过this对象来调用方法，所以就绕过了代理对象导致失效</p><p>以上两个问题可使用AspectJ代替SpringAOP代理解决。</p></li><li><p>事务方法内部捕获了异常（try catch）， 没有抛出新的异常，事务失效</p><p>原因：因为事务想要回滚，是在事务invokeWithinTranaction在这里会抛出异常，如果加事务的方法有了try catch，那么异常中途就会被捕捉掉，所以事务失效。，此时应该在try catch 中自己提交或者回滚</p></li><li><p>异常类型错误</p><p>默认回滚的是：RuntimeException非检查异常，如果你想触发其他异常的回滚，需要在注解上配置一下，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>(rollbackFor = Exception.class)</span><br></pre></td></tr></table></figure></li></ol><p>—- 3 解释：因为当ServiceB中抛出了一个异常以后，ServiceB标识当前事务需要rollback。但是ServiceA中由于你手动的捕获这个异常并进行处理，ServiceA认为当前事务应该正常commit。此时就出现了前后不一致，也就是因为这样，抛出了前面的UnexpectedRollbackException异常。</p><p>spring的事务是在调用业务方法之前开始的，业务方法执行完毕之后才执行commit or rollback，事务是否执行取决于是否抛出runtime异常。如果抛出runtime exception 并在你的业务方法中没有catch到的话，事务会回滚。</p><p>在业务方法中一般不需要catch异常，如果非要catch一定要抛出throw new RuntimeException()，或者注解中指定抛异常类型@Transactional(rollbackFor=Exception.class)，否则会导致事务失效，数据commit造成数据不一致，所以有些时候try catch反倒会画蛇添足。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/nextyu/article/details/78669997" target="_blank" rel="noopener">Spring Boot 中使用 @Transactional 注解配置事务管理</a><br><a href="https://www.ibm.com/developerworks/cn/java/j-master-spring-transactional-use/index.html" target="_blank" rel="noopener">透彻的掌握 Spring 中@transactional 的使用</a><br><a href="https://docs.spring.io/spring/docs/4.3.13.RELEASE/spring-framework-reference/htmlsingle/#transaction-declarative-annotations" target="_blank" rel="noopener">Spring Framework文档</a><br><a href="https://stackoverflow.com/questions/4396284/does-spring-transactional-attribute-work-on-a-private-method" target="_blank" rel="noopener">stackoverflow-transactional只能使用在public</a><br><a href="https://www.ibm.com/developerworks/cn/education/opensource/os-cn-spring-trans/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/education/opensource/os-cn-spring-trans/index.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring的事务管理分为编程式事务和声明式事务两种。
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>【Java】解析各种阻塞队列</title>
    <link href="http://yoursite.com/2019/10/21/Java%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/Java%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2019/10/21/Java基本知识/Java阻塞队列/</id>
    <published>2019-10-21T12:19:06.000Z</published>
    <updated>2019-10-28T12:34:29.632Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p><img src="/images/BlockingQueue.png" alt="BlockingQueue"></p><p>各种队列的基本操作，内部大都使用ReentrantLock和Condition进行入队出队的阻塞控制</p><table><thead><tr><th>操作</th><th>抛出异常</th><th>返回特殊值null</th><th>阻塞等待</th><th>超时返回false</th></tr></thead><tbody><tr><td>入队</td><td>add(E e)</td><td>offer(E e)</td><td>put(E e)</td><td>offer(E e,long timeout ,TimeUnit unit)</td></tr><tr><td>出队</td><td>remove(obj)</td><td>poll()</td><td>take()</td><td>poll(long timeout ,TimeUnit unit)</td></tr></tbody></table><a id="more"></a><h2 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h2><p>由数组实现的有界阻塞队列<br>大小构造函数确定，不能动态修改大小<br>默认非公平，可设置公平性</p><h2 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h2><p>由链表组成的有界阻塞队列，可从尾部和头部进行插入和删除操作<br>容量可选默认为Integer.MAX_VALUE，可设置大小防止过度膨胀<br>使用putFirst、putLast、pollFirst、pollLast内部又调用linkFirst、linkLast、unlinkFirst、unlinkLast方法进行队列的操作</p><h2 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h2><p>由二叉堆(小顶堆)实现的可设置优先级的无界阻塞队列，但不可保证同优先级元素的顺序<br>默认升序，可设置comparator<br>默认容量11，最大容量Integer.MAX_VALUE<br>扩容方式：  int newCap = oldCap + ((oldCap &lt; 64) ? (oldCap + 2) :  (oldCap &gt;&gt; 1));<br>                    // 容量小于64，则每次容量+2，否则变为1.5倍大小</p><h2 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h2><p>支持延时获取元素的无界阻塞队列<br>内部使用PriorityQueue优先队列，控制过期时间优先级，最先过期的优先级最高在队头<br>通过重入锁，和Condition控制阻塞，通过Thead leader对象来判断当前线程是否被占用<br>主要可使用在：清除过期缓存，超时任务处理</p><h2 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h2><p>不存储元素的BlockingQueue，每个put操作必须等待一个take，否则阻塞<br>可设置公平性，默认非公平，公平模式使用TransferQueue，非公平使用TransferStack<br>适合进行数据的转移</p><h2 id="LinkedTransferQueue"><a href="#LinkedTransferQueue" class="headerlink" title="LinkedTransferQueue"></a>LinkedTransferQueue</h2><p>入队时如果有消费者等待，就立即交出，如果没有就将元素添加到队尾<br>出队时如果队列中有元素就直接取出，如果没有就一直在这个位置等待直到拿到数据或者超时中断，此时tryTransfer()自旋若有新元素就不会进入队列，直接出队被消费者消费，不进行阻塞</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>Java并发编程艺术 方腾飞<br>Java并发编程实战  Brian Goetz / Tim Peierls / Joshua Bloch / Joseph Bowbeer / David Holmes / Doug Lea<br><a href="https://yq.aliyun.com/articles/577859" target="_blank" rel="noopener">java并发编程笔记–PriorityBlockingQueue实现</a><br><a href="http://cmsblogs.com/?p=2413" target="_blank" rel="noopener">【死磕Java并发】—–J.U.C之阻塞队列</a><br><a href="https://cloud.tencent.com/developer/article/1395130" target="_blank" rel="noopener">Java 优先队列 PriorityQueue PriorityBlockingQueue 源码分析</a></p>]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;p&gt;&lt;img src=&quot;/images/BlockingQueue.png&quot; alt=&quot;BlockingQueue&quot;&gt;&lt;/p&gt;&lt;p&gt;各种队列的基本操作，内部大都使用ReentrantLock和Condition进行入队出队的阻塞控制&lt;/p&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作&lt;/th&gt;
&lt;th&gt;抛出异常&lt;/th&gt;
&lt;th&gt;返回特殊值null&lt;/th&gt;
&lt;th&gt;阻塞等待&lt;/th&gt;
&lt;th&gt;超时返回false&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;入队&lt;/td&gt;
&lt;td&gt;add(E e)&lt;/td&gt;
&lt;td&gt;offer(E e)&lt;/td&gt;
&lt;td&gt;put(E e)&lt;/td&gt;
&lt;td&gt;offer(E e,long timeout ,TimeUnit unit)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;出队&lt;/td&gt;
&lt;td&gt;remove(obj)&lt;/td&gt;
&lt;td&gt;poll()&lt;/td&gt;
&lt;td&gt;take()&lt;/td&gt;
&lt;td&gt;poll(long timeout ,TimeUnit unit)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【Java】Reflect反射</title>
    <link href="http://yoursite.com/2019/10/19/Java%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/Java-Reflect/"/>
    <id>http://yoursite.com/2019/10/19/Java基本知识/Java-Reflect/</id>
    <published>2019-10-19T07:24:20.000Z</published>
    <updated>2019-11-01T05:39:28.064Z</updated>
    
    <content type="html"><![CDATA[<p>在JVM运行期，动态加载类或者调用方法，获取属性，事先不需要知道运行的对象是谁，解耦提高代码的灵活度</p><p>根据类名创建一个实例，不需要直接去new</p><a id="more"></a><p>在运行时<br>获取类的信息，类中字段信息，判断类所属的包<br>构造一个类的对象<br>动态调用方法</p><p>当获取私有字段时需要暴力反射：name.setAccessible(true)</p><p>缺点：<br>为了接口的通用性，Java的invoke方法是传object和object[]数组的。基本类型参数需要装箱和拆箱，产生大量额外的对象和内存开销，频繁促发GC。<br>编译器难以对动态调用的代码提前做优化，比如方法内联。<br>反射需要按名检索类和方法，有一定的时间开销。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在JVM运行期，动态加载类或者调用方法，获取属性，事先不需要知道运行的对象是谁，解耦提高代码的灵活度&lt;/p&gt;&lt;p&gt;根据类名创建一个实例，不需要直接去new&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【Java】类加载机制，全盘负责，双亲委派，类初始化过程</title>
    <link href="http://yoursite.com/2019/10/15/Java%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/JavaClassLoader/"/>
    <id>http://yoursite.com/2019/10/15/Java基本知识/JavaClassLoader/</id>
    <published>2019-10-15T13:29:14.000Z</published>
    <updated>2023-04-20T15:04:55.795Z</updated>
    
    <content type="html"><![CDATA[<p>类装载工作由ClassLoder和其子类负责。JVM在运行时会产生三个ClassLoader：(BootStrap)根装载器，ExtClassLoader(扩展类装载器)和AppClassLoader，其中根装载器不是ClassLoader的子类，由C++编写，因此在java中看不到他，负责装载JRE的核心类库。<a id="more"></a><br><img src="/images/ClassLoaderpng.png" alt="ClassLoader"></p><h2 id="全盘负责委托"><a href="#全盘负责委托" class="headerlink" title="全盘负责委托"></a>全盘负责委托</h2><p>Java装载类使用“全盘负责委托机制”指ClassLoader装载一个类时，除非显示的使用另一个ClassLoader，否则该类所依赖和引用的类也由这个ClassLoader载入。</p><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。<br>好处：保证任何的类加载器最终得到的是同一个Object对象</p><h3 id="双亲委派加载Class详细过程："><a href="#双亲委派加载Class详细过程：" class="headerlink" title="双亲委派加载Class详细过程："></a>双亲委派加载Class详细过程：</h3><blockquote><ol><li>源ClassLoader先判断该Class是否已加载，如果已加载，则返回Class对象；如果没有则委托给父类加载器。</li><li>父类加载器判断是否加载过该Class，如果已加载，则返回Class对象；如果没有则委托给祖父类加载器。</li><li>依此类推，直到始祖类加载器（引用类加载器）。</li><li>始祖类加载器判断是否加载过该Class，如果已加载，则返回Class对象；如果没有则尝试从其对应的类路径下寻找class字节码文件并载入。如果载入成功，则返回Class对象；如果载入失败，则委托给始祖类加载器的子类加载器。</li><li>始祖类加载器的子类加载器尝试从其对应的类路径下寻找class字节码文件并载入。如果载入成功，则返回Class对象；如果载入失败，则委托给始祖类加载器的孙类加载器。</li><li>依此类推，直到源ClassLoader。</li><li>源ClassLoader尝试从其对应的类路径下寻找class字节码文件并载入。如果载入成功，则返回Class对象；如果载入失败，源ClassLoader不会再委托其子类加载器，而是抛出异常。</li></ol></blockquote><h2 id="Java类加载过程"><a href="#Java类加载过程" class="headerlink" title="Java类加载过程"></a>Java类加载过程</h2><p>类装载器把一个类装入Java虚拟机中，要经过三个步骤来完成： </p><blockquote><p>①编译加载（以二进制形式来生成Class对象）<br>②链接（又分为验证、准备和解析）<br>       校验：检查导入类或接口的二进制数据的正确性；<br>       准备：给类的静态变量分配并初始化存储空间，初始化为默认值；<br>       解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；<br>③初始化（激活类的静态变量和静态代码块、初始化Java代码）</p></blockquote><h2 id="Java类初始化过程"><a href="#Java类初始化过程" class="headerlink" title="Java类初始化过程"></a>Java类初始化过程</h2><blockquote><p>先初始化静态成员，静态代码块，父类空白（构造）代码块，然后调用父类构造器，再初始化父类非静态成员，最后调用自身构造器，自身空白（构造）代码块，自身非静态成员。<br>1.父类静态变量、父类静态代码块 static{ }<br>2.子类静态变量、子类静态代码块 static{ }<br>3.父类字段初始化 ，如private String name =”base”<br>4.父类非静态代码块（空白代码块） {}                                                                                                 5.父类构造方法<br>6.子类字段初始化，如private String name=”sub”;<br>7.子类非静态代码块{}<br>8 子类构造方法</p></blockquote><h2 id="定义自已的类加载器"><a href="#定义自已的类加载器" class="headerlink" title="定义自已的类加载器"></a>定义自已的类加载器</h2><p>分为两步：</p><blockquote><p>1、继承java.lang.ClassLoader<br>2、重写父类的findClass方法</p></blockquote><p>为什么偏偏只重写findClass方法？</p><p>因为JDK已经在loadClass方法中帮我们实现了ClassLoader搜索类的算法，当在loadClass方法中搜索不到类时，loadClass方法就会调用findClass方法来搜索类，所以我们只需重写该方法即可。如没有特殊的要求，一般不建议重写loadClass搜索类的算法。</p><p>如果想保持双亲委派模型，就应该重写findClass(name)方法；如果想破坏双亲委派模型，可以重写loadClass(name)方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;类装载工作由ClassLoder和其子类负责。JVM在运行时会产生三个ClassLoader：(BootStrap)根装载器，ExtClassLoader(扩展类装载器)和AppClassLoader，其中根装载器不是ClassLoader的子类，由C++编写，因此在java中看不到他，负责装载JRE的核心类库。
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【Java】深浅拷贝，Object.Clone</title>
    <link href="http://yoursite.com/2019/10/15/Java%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>http://yoursite.com/2019/10/15/Java基本知识/深浅拷贝/</id>
    <published>2019-10-15T12:01:14.000Z</published>
    <updated>2019-11-01T05:41:06.232Z</updated>
    
    <content type="html"><![CDATA[<p>浅拷贝和深拷贝<br>浅拷贝，创建一个新对象，然后将当前对象的非静态字段复制到该对象，如果字段类型是基本数据类型就对字段进行复制，如果字段类型是引用类型则只复制该字段的引用而不复制引用指向的对象<br>修改复制的对象，原对象也会发生改变</p><a id="more"></a><p>深拷贝就是将所有字段的对象复制一份新的，修改复制的对象不会改变原对象</p><h2 id="Object-clone"><a href="#Object-clone" class="headerlink" title="Object.clone()"></a>Object.clone()</h2><p>源码<br>必须继承object，Java中所有类都默认继承Object，重写clone()，将clone的protected改为public，默认返回Object，必须要进行强制类型转换才能得到需要的类型，并且是浅拷贝</p><h2 id="实现深度拷贝"><a href="#实现深度拷贝" class="headerlink" title="实现深度拷贝"></a>实现深度拷贝</h2><p>方法1 将引用对象也实现Cloneable接口，<br>方法2 实现串行化接口，将对象的拷贝先写入流中，然后再读出，实现对象的重建</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;浅拷贝和深拷贝&lt;br&gt;浅拷贝，创建一个新对象，然后将当前对象的非静态字段复制到该对象，如果字段类型是基本数据类型就对字段进行复制，如果字段类型是引用类型则只复制该字段的引用而不复制引用指向的对象&lt;br&gt;修改复制的对象，原对象也会发生改变&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【Java】volatile关键字解析</title>
    <link href="http://yoursite.com/2019/10/15/Java%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/volatile/"/>
    <id>http://yoursite.com/2019/10/15/Java基本知识/volatile/</id>
    <published>2019-10-15T10:14:45.000Z</published>
    <updated>2019-10-15T10:37:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>volatile只能保证多线程中的可见性和有序性，不能保证原子性。<a id="more"></a><br>volatile关键字是否能保证线程安全？（）<br>答案：不能<br>解析：<br>volatile关键字用在多线程同步中<br>可保证读取的可见性（并发编程中当多个线程访问同一个变量时，一个线程对变量进行了修改，其他线程能够立马看到修改之后的值），<br>1.当某个线程对该变量修改后，会立即将修改后的新值刷回主存，保证主存中永远都是最新的数据<br>2.对该比变量施加了缓存行一致协议。也就是说，当前线程对该变量进行修改后，系统会通知其他线程它们工作缓存中数据已经无效，那么其他线程要再次读取该变量时，就会重新从主存中读取该变量，然后复制一份在它的工作缓存中。<br>JVM只是保证从主内存加载到线程工作内存的值是最新的读取值，而非cache中。</p><p>可保证有序性(程序按照代码的先后顺序进行执行)<br>能够禁止指令进行重排序，保证有序性<br>volatile关键字禁止指令重排序有两层意思：<br>1）当程序执行到volatile变量的读操作或者写操作时，在其前面作的操的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；<br>2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。</p><p>保证不了原子性问题(一个或多个操作，要么全部执行且不可被打断，要么都不执行)<br>可保证单一操作的原子性，不能保证复合操作的原子性<br>PS .      在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作<br>（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）<br>即这些操作是不可被中断的，要么执行，要么不执行。</p><p>i++执行了多部操作,从变量i中读取读取i的值-&gt;值+1 -&gt;将+1后的值写回i中，不能保证原子性和线程安全</p><p>在修饰数组时只是修饰指向数组的这个引用，而不是数组的内容，内容修改对其它线程不可见<br>主要的功能是保护变量不被主函数和中断函数反复修改造成读写错误。<br>但多个线程对volatile的写操作，无法保证线程安全。例如假如线程1，线程2 在进行read,load 操作中，发现主内存中count的值都是5，那么都会加载这个最新的值，在线程1堆count进行修改之后，会write到主内存中，主内存中的count变量就会变为6；线程2由于已经进行read,load操作，在进行运算之后，也会更新主内存count的变量值为6；导致两个线程即使用volatile关键字修改之后，还是会存在并发的情况。</p><p>参考链接：<br><a href="https://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="noopener">Java并发编程：volatile关键字解析</a><br><a href="http://cmsblogs.com/?p=2092" target="_blank" rel="noopener">死磕Java并发-深入理解volatile</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;volatile只能保证多线程中的可见性和有序性，不能保证原子性。
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【Redis】内存淘汰机制、缓存问题及解决、持久化方案</title>
    <link href="http://yoursite.com/2019/10/15/%E6%95%B0%E6%8D%AE%E5%BA%93/redis-study1/"/>
    <id>http://yoursite.com/2019/10/15/数据库/redis-study1/</id>
    <published>2019-10-15T08:47:48.000Z</published>
    <updated>2023-04-20T15:00:59.630Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>性能好，对一些结果变化不频繁的结果，存入缓存，加快请求响应<br>高并发进行削峰，减少同一时间对数据库的请求数量，防止数据库崩溃<a id="more"></a></p><p><strong>常用场景</strong></p><p>缓存，</p><p>计数器，</p><p>分布式锁，</p><p>排行榜，zset</p><p>最新列表，</p><p>消息队列</p><h2 id="Redis的常用基本数据类型"><a href="#Redis的常用基本数据类型" class="headerlink" title="Redis的常用基本数据类型"></a>Redis的常用基本数据类型</h2><blockquote><p>(一)string<br>内部使用sds实现，简单动态字符串。最常规的set/get操作，value可以是String也可以是数字。一般做一些复杂的计数功能的缓存。<br>(二)hash<br>内部使用zipmap(数据量少时使用)或者dict实现，这里value存放的是结构化的对象，比较方便的就是操作其中的某个字段。<br>(三)list<br>内部使用quicklist进行实现，quicklist的每一个节点都是ziplist，双向链表，使用List的数据结构，可以做简单的消息队列的功能。另外还有一个就是，可以利用lrange命令，做基于redis的分页功能，性能极佳，用户体验好。<br>(四)set<br>当set元素少时底层数据使用intset实现，否则使用dict实现。因为set堆放的是一堆不重复值的集合，所以可以做全局去重的功能。为什么不用JVM自带的Set进行去重？因为我们的系统一般都是集群部署，使用JVM自带的Set，比较麻烦，难道为了一个做一个全局去重，再起一个公共服务，太麻烦了。<br>另外，就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。<br>(五)sorted set<br>数据量少时使用ziplist，数据量多(数据对z的数目超过128或单个数据的长度超过64)使用dict(基于hash表，使用rehash进行冲突解决)和skiplist进行实现(zset)，sorted set多了一个权重参数score,集合中的元素能够按score进行排列。可以做排行榜应用，取TOP N操作、可以用来做延时任务、可以做范围查找。<br>当zset满足以下两个条件的时候，使用ziplist：</p><blockquote><ol><li>保存的元素少于128个</li><li>保存的所有元素大小都小于64字节</li></ol></blockquote><p>其他skiplist，多了一个权重参数score,集合中的元素能够按score进行排列。可以做排行榜应用，取TOP N操作、可以用来做延时任务、可以做范围查找。</p><p>延时队列：当前时间戳和延时时间相加，也就是到期时间，存入Redis中，然后不断轮询，拿出score比当前时间戳大的数据，找到到期的，拿到再删除即可</p></blockquote><hr><h2 id="Redis的内部数据结构"><a href="#Redis的内部数据结构" class="headerlink" title="Redis的内部数据结构"></a>Redis的内部数据结构</h2><p>主要有dict、sds、ziplist、quicklist、skiplist</p><blockquote><h3 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h3><p>dict基于Hash表的算法，使用拉链法解决冲突，在装在椅子超过预定的值时触发重哈希，重哈希使用的是增量式重hash，避免一次性对所有的key进行重hash造成单个请求的响应时间剧烈增加，每次只对一部分key进行重hash。dict里面包括两个哈希表dictint，在重哈希期间，数据从第一个哈希表转移到第二个哈希表。</p><h3 id="sds-simple-dynamic-string"><a href="#sds-simple-dynamic-string" class="headerlink" title="sds simple dynamic string"></a>sds simple dynamic string</h3><p>可以动态扩展，内容可增可修改。二进制安全，可打印任意二进制数据。</p><h3 id="ziplist"><a href="#ziplist" class="headerlink" title="ziplist"></a>ziplist</h3><p>经过编码的双向链表，存储效率高。各个数据项紧挨在一起占用连续的内存空间，不适合修改操作，如果数据发生变动引发realloc，可能会导致内存拷贝。</p><h3 id="quicklist"><a href="#quicklist" class="headerlink" title="quicklist"></a>quicklist</h3><p>双向链表，每一个节点都存储一个ziplist</p><h3 id="skiplist"><a href="#skiplist" class="headerlink" title="skiplist"></a>skiplist</h3><p>跳表，与hash表相比有序，hash表适合进行单个值得查找，不适合进行范围查找；平衡树的查找比跳表更加复杂，而且进行插入和删除时可能引发树的调整。</p><h3 id="intset"><a href="#intset" class="headerlink" title="intset"></a>intset</h3><p>整数组成的集合，内存分配与ziplist类似，连续的一整块内存空间，对大整数和小整数(绝对值)使用不同的编码方式，始终保持从小到大的顺序。</p><h3 id="robj"><a href="#robj" class="headerlink" title="robj"></a>robj</h3><p>redis object 根据type表示外部的数据类型(stirng、hash…)，根据字段encoding的不同可表示任意的上述内部数据类型(dict …)</p></blockquote><h2 id="Redis的RESP协议规范"><a href="#Redis的RESP协议规范" class="headerlink" title="Redis的RESP协议规范"></a>Redis的RESP协议规范</h2><blockquote><p>均已\r\n结尾</p><ol><li>简单字符串 Simple Strings, 以 “+”加号 开头</li><li>错误 Errors, 以”-“减号 开头</li><li>整数型Integer，以”:”冒号开头</li><li>多行字符串，以”$”美元符号开头</li><li>数组Arrays，以”*”星号开头</li></ol></blockquote><h2 id="单线程Redis为何这么快"><a href="#单线程Redis为何这么快" class="headerlink" title="单线程Redis为何这么快"></a>单线程Redis为何这么快</h2><blockquote><ol><li>纯内存操作</li><li>单线程，避免了频繁的上下文切换，不用考虑各种锁，每秒10w</li><li>使用了非阻塞IO多路复用，同一个线程同时处理多个请求</li><li>渐进式ReHash</li><li>缓存时间戳，不是调用系统时间，对时间进行缓存更新，获得时间是从缓存中取</li></ol></blockquote><p>渐进式rehash，使用两张全局哈希表，hash表2 是hash表1的2倍，将hash表1拷贝到hash表2，每一个客户端请求导致hash冲突只拷贝当前冲突，将一次性的拷贝分摊到了多次请求中</p><p>如果一张hash表处理冲突时，可能需要扩容，rehash后可能数据要移动，导致阻塞</p><h2 id="Redis的过期策略和内存淘汰机制，及内存不足的处理办法"><a href="#Redis的过期策略和内存淘汰机制，及内存不足的处理办法" class="headerlink" title="Redis的过期策略和内存淘汰机制，及内存不足的处理办法"></a>Redis的过期策略和内存淘汰机制，及内存不足的处理办法</h2><blockquote><p>redis64位内存默认大小无限制，查看info memory/config get maxmemory</p><p>比如你redis只能存5G数据，可是你写了10G，那会删5G的数据。怎么删的，这个问题思考过么？还有，你的数据已经设置了过期时间，但是时间到了，内存占用率还是比较高，有思考过原因么?<br>回答:<br>内存不足的处理办法：</p><ol><li>增加内存</li><li>对内存设置淘汰策略</li><li>使用redis集群</li></ol><p>redis采用的是<strong>定期删除+惰性删除</strong>策略。<br>为什么不用定时删除策略?<br>定时删除，用一个定时器来负责监视key，过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。在大并发请求下，CPU要将时间应用在处理请求，而不是删除key，因此没有采用这一策略.<br>定期删除+惰性删除是如何工作的呢?<br>定期删除，redis默认每隔100ms检查，是否有过期的key，有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms，全部key进行检查，redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。<br>于是，惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。<br>采用定期删除+惰性删除就没其他问题了么?<br>不是的，如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用内存淘汰机制。<br>在redis.conf中有一行配置<br><code>maxmemory-policy volatile-lru</code><br>该配置就是配内存淘汰策略的(什么，你没配过？好好反省一下自己)<br>1）noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。不推荐<br>2）allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。推荐使用，目前项目在用这种。<br>3）allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。应该也没人用吧，你不删最少使用Key,去随机删。<br>4）allkeys-lfu: 对所有的key，删除最少使用频率的<br>5）volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。这种情况一般是把redis既当缓存，又做持久化存储的时候才用。不推荐<br>6）volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。依然不推荐<br>7）volatile-lfu：对设置了过期的key中，删除最少使用频率的<br>6）volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。不推荐</p><p>ps：如果没有设置 expire 的key, 不满足先决条件(prerequisites); 那么 volatile-lru, volatile-random 和 volatile-ttl 策略的行为, 和 noeviction(不删除) 基本上一致。</p><p>近似lru算法，给每一个key增加一个小字段，最后一次被访问的时间戳，随机采样出几个key，根据时间戳淘汰，使用池化淘汰候选吃提升lru算法的效果</p></blockquote><h2 id="使用缓存的缺点"><a href="#使用缓存的缺点" class="headerlink" title="使用缓存的缺点"></a>使用缓存的缺点</h2><blockquote><ol><li>缓存和数据库双写一致性问题</li><li>缓存雪崩问题</li><li>缓存穿透问题</li><li>缓存并发竞争问题</li></ol></blockquote><h3 id="缓存一致性问题"><a href="#缓存一致性问题" class="headerlink" title="缓存一致性问题"></a>缓存一致性问题</h3><blockquote><p>一致性分为最终一致性（通俗来说就是最后结果相同）和强一致性(每时每刻都是相同的)。<br>强一致性要求的需要加锁。</p><p>双写模式，先写数据库改完之后写缓存，数据不一致，第一个写缓存在第二个写缓存之后，缓存设置过期时间，过期之后又能得到新的正确的，最终一致</p><p>cache aside 机制<br>失效模式：<strong>先更新数据库，再删除缓存</strong>，也可能造成暂时不一致 线程a写数据库1，线程b写2，线程c读，b还未写完，c读到数据库为1，更新缓存为1</p><p>失效：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。<br>命中：应用程序从cache中取数据，取到后返回。<br>更新：先把数据存到数据库中，成功后，再让缓存失效。</p><p><img src="C:\Users\jcy\AppData\Roaming\Typora\typora-user-images\image-20210318231946646.png" alt="image-20210318231946646"></p></blockquote><p>先删缓存再更新数据库。使用延时双删策略解决暂时不一致性，先删缓存再写数据库，休眠1s，再删除缓存<br>先更新db 后删除缓存</p><p>Read/Write Through机制，调用方只和缓存交互，读直接读缓存，写先写入缓存，由缓存同步到数据库</p><h3 id="缓存雪崩问题"><a href="#缓存雪崩问题" class="headerlink" title="缓存雪崩问题"></a>缓存雪崩问题</h3><blockquote><p>缓存雪崩，即缓存失效时间相同，同一时间大面积的失效，或者redis故障失效（集群解决，hystrix限流），这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。<br>解决方案:</p><ol><li>给缓存的失效时间，加上一个随机值，避免集体失效。</li><li>使用互斥锁，但是该方案吞吐量明显下降了。 </li><li>多级缓存。我们有两个缓存，缓存A和缓存B。缓存A的失效时间为20分钟，缓存B不设失效时间。自己做缓存预热操作。然后细分以下几个小点<blockquote><p>I 从缓存A读数据库，有则直接返回<br>II A没有数据，直接从B读数据，直接返回，并且异步启动一个更新线程。<br>III 更新线程同时更新缓存A和缓存B。</p></blockquote></li></ol></blockquote><h3 id="缓存穿透问题"><a href="#缓存穿透问题" class="headerlink" title="缓存穿透问题"></a>缓存穿透问题</h3><blockquote><p>缓存穿透，即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。<br>解决方案:</p><ol><li>采用异步更新策略，无论key是否取到值，都直接返回。value值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做缓存预热(项目启动前，先加载缓存)操作。</li><li>提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的key。迅速判断出，请求所携带的Key是否合法有效。如果不合法，则直接返回。适用于大用户集，实时性要求较低的场景，如有几亿的数据集，每隔一段时间会新增用户进去，在更新之前新用户的访问会存在缓存穿透问题。</li><li>利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试</li></ol></blockquote><h3 id="缓存击穿问题"><a href="#缓存击穿问题" class="headerlink" title="缓存击穿问题"></a>缓存击穿问题</h3><blockquote><p>对于一些设置了过期时间的key，可能是一个热点数据，在某时高并发访问，此时正好失效，所有数据查询都查数据库</p><p>解决方案：加锁，利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试</p></blockquote><h3 id="Redis缓存并发竞争"><a href="#Redis缓存并发竞争" class="headerlink" title="Redis缓存并发竞争"></a>Redis缓存并发竞争</h3><blockquote><ol><li>基于zookeeper实现分布式锁，每个通过zookeeper获取分布式锁，确保同一时间，只有一个实例在操作某个key。当进行写之前，判断当前的value时间戳是否比缓存里面的时间戳新，若是则写，否则，不能使用旧数据覆盖新数据。</li><li>redis 的 setnx 实现内置的锁：<br>要设置超时时间，防止抢占到锁的客户端因失败、崩溃或其他原因没有办法释放锁而造成死锁</li><li>利用redis自带的incr命令,decr命令</li><li>使用乐观锁的方式进行解决，通过watch进行监控，后面的事务有条件执行，如果在watch的exec执行时，watch的key对应的value改变了，事务不进行执行，但是不推荐使用redis的事务机制。因为我们的生产环境，基本都是redis集群环境，做了数据分片操作。你一个事务中有涉及到多个key操作的时候，这多个key不一定都存储在同一个redis-server上。</li></ol></blockquote><h2 id="Redis持久化方案"><a href="#Redis持久化方案" class="headerlink" title="Redis持久化方案"></a>Redis持久化方案</h2><blockquote><ol><li>RDB在指定的时间间隔能对你的数据进行快照存储。执行bgsave</li><li>AOF使用日志记录所有的写操作，在服务器启动时，通过执行这些命令还原数据库。<br>AOF的持久化更加完整，安全，默认每秒钟fsync一次，出现故障时可使用redis-check-aof进行问题修复，并且自己可以对aof文件进行重写<br>RDB可能会丢失数据，但是体积更小，保存某个时间点的所有数据，进行大数据集恢复时速度要快<br>一般两种方式同时使用，在同时使用时，<font color="red">优先使用AOF进行数据集的恢复</font></li></ol><p>AOF 的工作流程，写入命令追加到缓冲区，根据策略对硬盘进行同步，定期对AOF文件进行重写</p></blockquote><p>Canal</p><p>更新缓存：mysql 的从服务器，只要更新了DB，Canal更新redis</p><p>解决数据异构：不同用户生成不同的表</p><p>为什么redis需要把所有数据放到内存中</p><p>速度快，存在过期淘汰机制不会出现oom</p><h3 id="redis-哨兵模式"><a href="#redis-哨兵模式" class="headerlink" title="redis 哨兵模式"></a>redis 哨兵模式</h3><p>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。</p><p>当哨兵监测到master宕机，会自动将slave切换成master，然后通过<strong>发布订阅模式</strong>通知其他的从服务器，修改配置文件，让它们切换主机</p><p><strong>故障切换（failover）</strong>的过程。假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为<strong>主观下线</strong>。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为<strong>客观下线</strong></p><h2 id="选举步骤"><a href="#选举步骤" class="headerlink" title="选举步骤"></a>选举步骤</h2><p>故障节点主观下线<br>故障节点客观下线<br>Sentinel集群选举Leader<br>Sentinel Leader决定新主节点<br>选举过程<br>1、主观下线<br>Sentinel集群的每一个Sentinel节点会定时对redis集群的所有节点发心跳包检测节点是否正常。如果一个节点在down-after-milliseconds时间内没有回复Sentinel节点的心跳包，则该redis节点被该Sentinel节点主观下线。</p><p>2、客观下线<br>当节点被一个Sentinel节点记为主观下线时，并不意味着该节点肯定故障了，还需要Sentinel集群的其他Sentinel节点共同判断为主观下线才行。</p><p>该Sentinel节点会询问其他Sentinel节点，如果Sentinel集群中超过quorum数量的Sentinel节点认为该redis节点主观下线，则该redis客观下线。</p><p>如果客观下线的redis节点是从节点或者是Sentinel节点，则操作到此为止，没有后续的操作了；如果客观下线的redis节点为主节点，则开始故障转移，从从节点中选举一个节点升级为主节点。</p><p>3、Sentinel集群选举Leader<br>如果需要从redis集群选举一个节点为主节点，首先需要从Sentinel集群中选举一个Sentinel节点作为Leader。</p><p>每一个Sentinel节点都可以成为Leader，当一个Sentinel节点确认redis集群的主节点主观下线后，会请求其他Sentinel节点要求将自己选举为Leader。被请求的Sentinel节点如果没有同意过其他Sentinel节点的选举请求，则同意该请求(选举票数+1)，否则不同意。</p><p>如果一个Sentinel节点获得的选举票数达到Leader最低票数(quorum和Sentinel节点数/2+1的最大值)，则该Sentinel节点选举为Leader；否则重新进行选举。</p><p>4、Sentinel Leader决定新主节点<br>当Sentinel集群选举出Sentinel Leader后，由Sentinel Leader从redis从节点中选择一个redis节点作为主节点：</p><p>过滤故障的节点<br>选择优先级slave-priority最大的从节点作为主节点，如不存在则继续<br>选择复制偏移量（数据写入量的字节，记录写了多少数据。主服务器会把偏移量同步给从服务器，当主从的偏移量一致，则数据是完全同步）最大的从节点作为主节点，如不存在则继续<br>选择runid（redis每次启动的时候生成随机的runid作为redis的标识）最小的从节点作为主节点</p><p>为什么Sentinel集群至少3节点<br>一个Sentinel节选举成为Leader的最低票数为quorum和Sentinel节点数/2+1的最大值，如果Sentinel集群只有2个Sentinel节点，则</p><p>Sentinel节点数/2 + 1= 2/2 + 1<br>即Leader最低票数至少为2，当该Sentinel集群中由一个Sentinel节点故障后，仅剩的一个Sentinel节点是永远无法成为Leader。</p><p>也可以由此公式可以推导出，Sentinel集群允许1个Sentinel节点故障则需要3个节点的集群；允许2个节点故障则需要5个节点集群。</p><h3 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h3><p><strong>全量同步</strong></p><p>Redis全量复制一般发生在Slave初始化阶段，这时Slave需要将Master上的所有数据都复制一份。具体步骤如下： </p><ul><li>从服务器连接主服务器，发送SYNC命令； </li><li>主服务器接收到SYNC命名后，开始执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令； </li><li>主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令； </li><li>从服务器收到快照文件后丢弃所有旧数据，载入收到的快照； </li><li>主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令； </li><li>从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；</li></ul><p><strong>增量同步</strong></p><p>Redis增量复制是指Slave初始化后开始正常工作时主服务器发生的写操作同步到从服务器的过程。 </p><p>增量复制的过程主要是主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令。</p><p><strong>Redis主从同步策略</strong></p><p>主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。</p><p>主从复制是从节点异步复制备份，可能会存在写操作数据丢失</p><p>Redis 事务</p><p>MULTI EXEC WATCH UNWATCH</p><p><strong>Redis 分布式锁</strong><br>setnx  互斥能力，，如果进程异常，没及时释放锁，造成死锁<br>设置失效时间，看门狗守护线程，定时检测锁的失效时间，如果操作还未完成，进行自动锁续期</p><p><strong>Redis 消息队列</strong><br>基于列表lpush，brpop/blpop，不能重复消费，不能广播，不能保证消费者消费者消费后是否成功处理<br>基于sorted-set，多用来实现延迟消息队列，只能轮询，不允许重复消费消息<br>pub/sub，订阅/发布模式，广播模式，即时发送，发布时若客户端故障，消息丢失，不能寻回；不能保证每个消费者接收的时间时一致的，出现消息积压会强制断开，导致消息丢失，适合及时通讯不适合消息存储<br>redis5.0基于stream链表，消费者组借鉴kafka设计，有一个固定最大长度，超过会把老消息干掉</p><p>bigkey<br>字符串类型，单个value值很大，超过10kb就算bigkey<br>非字符串类型，元素个数过多</p><p>缺点：<br>内存空间分布不均匀<br>超时阻塞<br>网络阻塞，获取bigkey，产生网络流量较大</p><p>Redis 如何解决key冲突<br>业务隔离，key的设计，分布式锁（多个客户端并发写）</p><p>如何提高缓存命中<br>提前加载，<br>增加缓存的存储空间，提高缓存的数据，提高命中率，<br>调整缓存的存储类型，<br>提升缓存的更新频次</p><p>热点数据<br>考虑使用缓存，不重要的点赞数<br>数据更新之前至少读取两次</p><p>1、客户端阻塞命令，keys，smembers<br>2、bigkey 删除 100w大概删2s<br>3、清空库 flushall<br>4、aof日志同步，大量写操作 同步写磁盘<br>5、从库加载rdb</p><p>什么时候使用redis，memchached</p><ol><li>redis功能更强大，可以持久化aof，rdb</li><li>redis 内存可过期，淘汰，memcached预分配管理</li><li>redis io多路复用，子任务 锁冲突；memcached 非阻塞多路复用，多线程</li><li>redis 事务，主从复制，lua mq</li></ol><p><strong>Redis性能问题</strong></p><ol><li>持久化，全量复制部分复制，主节点不做持久化，从节点进行持久化操作</li><li>数据比较重要开启aof持久化，slave每秒同步一次</li><li>主从复制的流畅，同一个局域网</li><li>避免主库压力很大，增加从库</li><li>不要采用网状结构</li></ol><p>setIfAbsent</p><p>Redisson进行分布式锁</p><h3 id="Redis-集群"><a href="#Redis-集群" class="headerlink" title="Redis 集群"></a>Redis 集群</h3><p>1、客户端分区方案，优点分区逻辑可控，缺点是需要自己处理数据路由，高可用，故障转移<br>2、代理方案，优点是简化客户端分布式逻辑和升级维护便利，缺点加重了架构部署复杂度和性能损耗</p><p>官方解决方案：Redis Cluster<br>分槽slot<br>集群功能限制<br>1、key批量操偶做支持有限，mset，mget只支持具有slot的key执行批量操作<br>2、key事务操作支持有限，只支持多key在同一节点上的事务操作<br>3、key作为数据分区的最小粒度，不能将一个大的键值对象如hash，list映射到不同的节点<br>4、不支持多数据库空间，单机下Redis支持16个数据库，集群模式只能用一个数据库空间db0<br>5、复制结构只支持一层，从节点只能复制主节点，不支持嵌套树状复制结构</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.cnblogs.com/rjzheng/p/9096228.html" target="_blank" rel="noopener">分布式之redis复习精讲</a><br><a href="https://mp.weixin.qq.com/s__biz=MjM5ODYxMDA5OQ==&amp;mid=404308725&amp;idx=1&amp;sn=1a25ce76dd1956014ceb8a011855268e&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">主从DB与cache一致性</a><br><a href="https://www.cnblogs.com/haifeiWu/p/9440988.html#autoid-8-0-0" target="_blank" rel="noopener">Redis协议规范（译文）</a><br><a href="http://www.redis.cn/topics/persistence.html" target="_blank" rel="noopener">Redis官方持久化</a><br><a href="https://segmentfault.com/a/1190000014262882" target="_blank" rel="noopener">Redis使用中存在的问题</a><br><a href="https://coolshell.cn/articles/17416.html" target="_blank" rel="noopener">缓存更新套路</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Redis&quot;&gt;&lt;a href=&quot;#Redis&quot; class=&quot;headerlink&quot; title=&quot;Redis&quot;&gt;&lt;/a&gt;Redis&lt;/h2&gt;&lt;p&gt;性能好，对一些结果变化不频繁的结果，存入缓存，加快请求响应&lt;br&gt;高并发进行削峰，减少同一时间对数据库的请求数量，防止数据库崩溃
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>【Java】AQS(AbstractQueuedSynchronizer)队列同步器</title>
    <link href="http://yoursite.com/2019/10/11/Java%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/AQS/"/>
    <id>http://yoursite.com/2019/10/11/Java基本知识/AQS/</id>
    <published>2019-10-11T10:11:45.000Z</published>
    <updated>2023-08-26T08:44:42.521Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AQS-AbstractQueuedSynchronizer抽象队列同步器"><a href="#AQS-AbstractQueuedSynchronizer抽象队列同步器" class="headerlink" title="AQS(AbstractQueuedSynchronizer抽象队列同步器)"></a>AQS(AbstractQueuedSynchronizer抽象队列同步器)</h2><p>JUC包里面的类使用继承AQS进行并发实现，子类通过继承同步器抽象方法来管理同步状态，只能在一个时刻发生阻塞，从而降低上下文切换的开销，提高了吞吐量。</p><a id="more"></a><p>状态控制：<br>private volatile int state;<br>使用int类型的成员变量state来表示同步状态，当state&gt;0时表示已经获取了锁，当state = 0时表示释放了锁。<br>getState()：返回同步状态的当前值；<br>setState(int newState)：设置当前同步状态；<br>compareAndSetState(int expect, int update)：使用CAS设置当前状态，该方法能够保证状态设置的原子性；</p><h3 id="AQS内的CLH同步队列"><a href="#AQS内的CLH同步队列" class="headerlink" title="AQS内的CLH同步队列"></a>AQS内的CLH同步队列</h3><p>对同步状态的获取和释放<br>FIFO的双向队列，AQS依赖它来完成同步状态的管理，当前线程如果获取同步状态失败时，AQS则会将当前线程已经等待状态等信息构造成一个节点（Node）并将其加入到CLH同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点唤醒（公平锁），使其再次尝试获取同步状态。</p><h3 id="AQS使用的LockSupport"><a href="#AQS使用的LockSupport" class="headerlink" title="AQS使用的LockSupport"></a>AQS使用的LockSupport</h3><p>对线程的阻塞和唤醒<br>LockSupport 不可重入，一个线程连续两次调用park()，将会产生死锁，一直阻塞<br>park()：阻塞线程，<br>unpark()：唤醒线程</p><p>参考链接<br><a href="http://cmsblogs.com/?p=2174" target="_blank" rel="noopener">【死磕Java并发】—–J.U.C之AQS</a><br><a href="http://cmsblogs.com/?p=2197" target="_blank" rel="noopener">J.U.C之AQS：同步状态的获取与释放</a><br><a href="https://blog.csdn.net/aitangyong/article/details/38373137?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">LockSupport的park和unpark的基本使用,以及对线程中断的响应性</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;AQS-AbstractQueuedSynchronizer抽象队列同步器&quot;&gt;&lt;a href=&quot;#AQS-AbstractQueuedSynchronizer抽象队列同步器&quot; class=&quot;headerlink&quot; title=&quot;AQS(AbstractQueuedSynchronizer抽象队列同步器)&quot;&gt;&lt;/a&gt;AQS(AbstractQueuedSynchronizer抽象队列同步器)&lt;/h2&gt;&lt;p&gt;JUC包里面的类使用继承AQS进行并发实现，子类通过继承同步器抽象方法来管理同步状态，只能在一个时刻发生阻塞，从而降低上下文切换的开销，提高了吞吐量。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【Java】普通容器，同步容器和并发容器</title>
    <link href="http://yoursite.com/2019/10/10/Java%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/Java%E5%AE%B9%E5%99%A8/"/>
    <id>http://yoursite.com/2019/10/10/Java基本知识/Java容器/</id>
    <published>2019-10-10T01:17:47.000Z</published>
    <updated>2022-02-27T08:25:43.854Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java容器"><a href="#Java容器" class="headerlink" title="Java容器"></a>Java容器</h2><p>本文主要对Java中的容器进行介绍，主要分为普通容器，同步容器和并发容器<a id="more"></a></p><p><img src="/images/1570411257098.png" alt="1570411257098"></p><h3 id="普通容器"><a href="#普通容器" class="headerlink" title="普通容器"></a>普通容器</h3><ul><li><p>ArrayList：适合读取O(1)，默认初始容量为10，size()是实际元素的个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Default initial capacity.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>扩容方式，自动扩容还需要进行一个copy，消耗的资源较多 ，尽可能设置好初始大小</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// overflow-conscious code</span></span><br><span class="line">      <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">      <span class="comment">// 默认新容量为原来的1.5倍，old+old/2</span></span><br><span class="line">      <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// 若新容量比需要容量小，则以需要的容量为准</span></span><br><span class="line">      <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">          newCapacity = minCapacity;</span><br><span class="line">    <span class="comment">// 如果新容量比最大容量还大，则使用最大容量</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">          newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">      <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">      <span class="comment">// 以新容量的大小拷贝一个新ArrayList</span></span><br><span class="line">      elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>LinkedList 适合添加和删除 O(1)，查找O(n)</p></li><li><p>HashMap 实现了Map接口，底层由数组bucket+链表(散列表)+红黑树实现，几种数据结构存的都是键值对，hashcode相同bucket位置来储存Entry对象，当出现hash冲突时使用链表存储entry插入开头，当冲突数大于8时使用红黑树存储，使用链表键值可以为null，初始容量16，当元素数量达到总容量的0.75扩容，扩容方式2的n次方</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//The default initial capacity - MUST be a power of two.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; </span><br><span class="line"><span class="comment">// aka 16</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="遍历删除"><a href="#遍历删除" class="headerlink" title="遍历删除"></a>遍历删除</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//list</span></span><br><span class="line">Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line"> <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">  String x = it.next();</span><br><span class="line">  <span class="keyword">if</span>(x.equals(<span class="string">"del"</span>))&#123;</span><br><span class="line">    it.remove();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//map</span></span><br><span class="line">Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; it = map.entrySet().iterator();</span><br><span class="line">  <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    Map.Entry&lt;Integer, String&gt; entry = it.next();</span><br><span class="line">    Integer key = entry.getKey();</span><br><span class="line">    <span class="keyword">if</span>(key % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">       System.out.println(<span class="string">"To delete key "</span> + key);</span><br><span class="line">       it.remove();  </span><br><span class="line">       System.out.println(<span class="string">"The key "</span> + + key + <span class="string">" was deleted"</span>);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li><p>Map相关<br>  HashMap:内部结构是哈希表+红黑树，键和值都可以是空对象，不保证映射的顺序，多次访问，映射元素的顺序可能不同，非线程安全。默认大小为16，扩容方式，2的指数 </p><p>  HashTable:线程安全的HashMap，默认大小为11，扩容方式为old*2+1</p><p>  LinkedHashMap:可按put顺序遍历输出。<br>WeakHashMap:主要用来实现缓存，被WeakHashMap关联的对象在下一次JVM垃圾回收时会被回收，非线程安全。<br>  SortedMap:键按升序排序，所有键必须实现Comparable接口。<br>  TreeMap:内部为红黑树实现，不同步，可对Map集合中的键进行排序。</p><p>  IdentityHashMap：可支持多个重复key，靠对象判断key是否相等</p></li><li><p>Set相关<br>一个不允许重复元素的Collection，可以有一个空元素，不可随机访问包含的元素，只能用Iterator实现单向遍历，Set不同步。下面接口实现都是非安全的。<br>HashSet: 内部数据结构是HashMap，使用HashMap的key存储元素，value全是一样的虚拟元素PRESENT，由于HashMap的特性所以HashSet元素是唯一的，元素是无序的，允许有一个null，迭代访问元素的顺序和加入的顺序不同，多次迭代访问，元素的顺序可能不同。<br>LinkedHashSet: 基于LinkedHashMap实现，迭代访问元素的顺序和加入的顺序相同，多次迭代访问，元素的顺序不变，与LinkedHashMap访问区别：不支持按访问顺序排序，只能按插入顺序排序。<br>TreeSet: 基于TreeMap实现，存在NavigableMap接口的一个对象m，实际上为其实现类TreeMap的实例，可以看做是NavigableMap组合TreeMap，可以对Set集合中的元素进行排序，排序后按自然升序排列元素，可传入自定义的Comparator。</p></li><li><p>如何比较两个List是否相等<br>设定一个标记数组，标记是否找到过  </p></li><li><p>如何比较两个Set元素是否相等<br>Set不重复，先判断数量是否相等，再做一次嵌套循环，比较A中元素是否在B中</p></li><li><p>如何保证ArrayList的安全</p><ol><li>使用Collections里面的SynchronizedList的方法，全部读写都加锁，效率不高</li><li>使用CopyOnWriteArrayList，适合读多写少的情况，读写分离，读操作不加锁，写操作使用ReentrantLock重入锁，读操作支持随机访问O(1)，保证最终一致性，不保证强一致性。在List发生变化时(增删)O(n)，都会调用Arrays.copyOf()对原数组进行复制，造成内存损耗。</li></ol></li><li><p>如何保证Set的安全性</p><ol><li>使用Collections里面的newSetFromMap，将ConcurrentHashMap转换为Set</li><li>使用CopyOnWriteArraySet：内部通过CopyOnWriteArrayList实现，有序，并发安全，读写分离，通过AddIfAbsent()方法保证元素不重复</li></ol></li></ul><h3 id="同步容器"><a href="#同步容器" class="headerlink" title="同步容器"></a>同步容器</h3><ul><li><p>Vector </p></li><li><p>Stack 继承自Vector，先进后出</p></li><li><p>HashTable 其中都是使用synchronized进行修饰，保证同一个变量只能由一个线程访问</p></li><li><p>Collections下的</p><p>List list = Collections.synchronizedList(new ArrayList());<br>Set set = Collections.synchronizedSet(new HashSet());<br>Map map = Collections.synchronizedMap(new HashMap());</p></li><li><p>同步容器和并发容器的区别</p><ul><li>同步容器，方法上都加入了synchronized进行同步控制，但是做复合操作：迭代（反复访问元素，遍历完容器中的所有元素）、跳转（根据指定的顺序找到当前元素的下一个元素）、以及条件运算时不一定安全，对一个线程来说是安全的，但是多个线程操作就会出现异常</li><li>并发容器，主要通过CAS进行并发控制，内部也可能会使用synchronized和锁进行控制</li></ul></li></ul><h3 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h3><ul><li>ConcurrentHashMap 和Hashmap的存储方式一样，但是通过对数组进行加锁synchronized和使用CAS(Compare And Swap)进行并发控制</li><li>ConcurrentSkipListMap - 线程安全的有序 Map。使用跳表实现高效并发。</li><li>CopyOnWriteArrayList - 线程安全的 ArrayList</li><li>CopyOnWriteArraySet - 线程安全的 Set，它内部包含了一个 </li><li>CopyOnWriteArrayList，因此本质上是由 CopyOnWriteArrayList 实现</li><li>ConcurrentSkipListSet - 相当于线程安全的 TreeSet。它是有序的 Set。它由 ConcurrentSkipListMap 实现。</li><li>CopyOnWriteArraySet - 线程安全的 Set，它内部包含了一个CopyOnWriteArrayList，因此本质上是由 CopyOnWriteArrayList 实现</li><li>ConcurrentHashMap - 线程安全的 HashMap。采用分段锁实现高效并发。</li><li>ConcurrentSkipListMap - 线程安全的有序 Map。使用跳表实现高效并发。</li><li>ConcurrentLinkedQueue - 线程安全的无界队列。底层采用单链表。支持 FIFO。</li><li>ConcurrentLinkedDeque - 线程安全的无界双端队列。底层采用双向链表。支持 FIFO 和 FILO。</li><li>各种阻塞队列使用 </li><li>ArrayBlockingQueue - 数组实现的阻塞队列。</li><li>LinkedBlockingQueue - 单链表实现的阻塞队列。</li><li>LinkedBlockingDeque - 双向链表实现的双端阻塞队列。</li></ul><h2 id="集合注意点"><a href="#集合注意点" class="headerlink" title="集合注意点"></a>集合注意点</h2><ol><li>能用isEmpty不用size()，size()一般需要进行遍历</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Java容器&quot;&gt;&lt;a href=&quot;#Java容器&quot; class=&quot;headerlink&quot; title=&quot;Java容器&quot;&gt;&lt;/a&gt;Java容器&lt;/h2&gt;&lt;p&gt;本文主要对Java中的容器进行介绍，主要分为普通容器，同步容器和并发容器
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
</feed>
