<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>贝西晨的Blog呀</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-10-02T15:21:12.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>beixichen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Spring学习笔记3】Spring动态代理</title>
    <link href="http://yoursite.com/2019/10/02/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/proxy-study/"/>
    <id>http://yoursite.com/2019/10/02/Spring学习笔记/proxy-study/</id>
    <published>2019-10-02T15:12:17.000Z</published>
    <updated>2019-10-02T15:21:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="动态代理："><a href="#动态代理：" class="headerlink" title="动态代理："></a>动态代理：</h2><p>   特点：字节码随用随创建，随用随加载<br>   作用：不修改源码的基础上对方法增强<a id="more"></a><br>   分类：<br>       基于接口的动态代理<br>       基于子类的动态代理<br>   基于子类的动态代理：<br>       涉及的类：Enhancer<br>       提供者：第三方cglib库<br>   如何创建代理对象：<br>       使用Enhancer类中的create方法<br>   创建代理对象的要求：<br>       被代理类不能是最终类<br>   create方法的参数：<br>       Class：字节码<br>           它是用于指定被代理对象的字节码。<br>   callback：用于提供增强的代码<br>        它是让我们写如何代理。我们一般都是些一个该接口的实现类，通常情况下都是匿名内部类，但不是必须的。<br>        此接口的实现类都是谁用谁写。<br>        我们一般写的都是该接口的子接口实现类：MethodInterceptor</p><h2 id="通过接口实现动态代理"><a href="#通过接口实现动态代理" class="headerlink" title="通过接口实现动态代理"></a>通过接口实现动态代理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">IProducer proxyProducer = (IProducer) Proxy.newProxyInstance(producer.getClass().getClassLoader(),</span><br><span class="line">producer.getClass().getInterfaces(),</span><br><span class="line"><span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 作用：执行被代理对象的任何接口方法都会经过该方法</span></span><br><span class="line"><span class="comment"> * 方法参数的含义</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> proxy   代理对象的引用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> method  当前执行的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args    当前执行方法所需的参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>        和被代理对象方法有相同的返回值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="comment">//提供增强的代码</span></span><br><span class="line">Object returnValue = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.获取方法执行的参数</span></span><br><span class="line">Float money = (Float)args[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//2.判断当前方法是不是销售</span></span><br><span class="line"><span class="keyword">if</span>(<span class="string">"saleProduct"</span>.equals(method.getName())) &#123;</span><br><span class="line">returnValue = method.invoke(producer, money*<span class="number">0.8f</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> returnValue;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">proxyProducer.saleProduct(<span class="number">10000f</span>);</span><br></pre></td></tr></table></figure><h2 id="通过cglib实现动态代理"><a href="#通过cglib实现动态代理" class="headerlink" title="通过cglib实现动态代理"></a>通过cglib实现动态代理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Producer cglibProducer = (Producer)Enhancer.create(producer.getClass(), <span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行北地阿里对象的任何方法都会经过该方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> proxy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"> *    以上三个参数和基于接口的动态代理中invoke方法的参数是一样的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> methodProxy ：当前执行方法的代理对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="comment">//提供增强的代码</span></span><br><span class="line">Object returnValue = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.获取方法执行的参数</span></span><br><span class="line">Float money = (Float)args[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//2.判断当前方法是不是销售</span></span><br><span class="line"><span class="keyword">if</span>(<span class="string">"saleProduct"</span>.equals(method.getName())) &#123;</span><br><span class="line">returnValue = method.invoke(producer, money*<span class="number">0.8f</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> returnValue;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">cglibProducer.saleProduct(<span class="number">12000f</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;动态代理：&quot;&gt;&lt;a href=&quot;#动态代理：&quot; class=&quot;headerlink&quot; title=&quot;动态代理：&quot;&gt;&lt;/a&gt;动态代理：&lt;/h2&gt;&lt;p&gt;   特点：字节码随用随创建，随用随加载&lt;br&gt;   作用：不修改源码的基础上对方法增强
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Java/Spring/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>【Spring学习笔记2】常用的各种注解及替代xml配置的作用</title>
    <link href="http://yoursite.com/2019/10/02/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Spring-study2/"/>
    <id>http://yoursite.com/2019/10/02/Spring学习笔记/Spring-study2/</id>
    <published>2019-10-02T13:06:40.000Z</published>
    <updated>2019-10-02T14:54:25.767Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">""</span> <span class="attr">class</span>=<span class="string">""</span> <span class="attr">scope</span>=<span class="string">""</span>  <span class="attr">init-method</span>=<span class="string">""</span> <span class="attr">destroy-method</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">""</span>  <span class="attr">value</span>=<span class="string">""</span> | <span class="attr">ref</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="用于创建对象"><a href="#用于创建对象" class="headerlink" title="用于创建对象"></a>用于创建对象</h2><blockquote><p>他们的作用就和在XML配置文件中编写一个<bean>标签实现的功能是一样的<br>Component:<br>    作用：用于把当前类对象存入spring容器中<br>    属性：<br>        value：用于指定bean的id。当我们不写时，它的默认值是当前类名，且首字母改小写。<br><br>Controller：一般用在表现层<br>Service：一般用在业务层<br>Repository：一般用在持久层<br>以上三个注解他们的作用和属性与Component是一模一样。<br>他们三个是spring框架为我们提供明确的三层使用的注解，使我们的三层对象更加清晰</bean></p></blockquote><h2 id="用于注入数据"><a href="#用于注入数据" class="headerlink" title="用于注入数据"></a>用于注入数据</h2><blockquote><p>他们的作用就和在xml配置文件中的bean标签中写一个<property>标签的作用是一样的<br>@Autowired:<br>    作用：自动按照类型注入。只要容器中有唯一的一个bean对象类型和要注入的变量类型匹配，就可以注入成功<br>          如果ioc容器中没有任何bean的类型和要注入的变量类型匹配，则报错。<br>          如果Ioc容器中有多个类型匹配时：<br>    出现位置：<br>        可以是变量上，也可以是方法上<br>    细节：<br>        在使用注解注入时，set方法就不是必须的了。<br><br>@Qualifier:<br>    作用：在按照类中注入的基础之上再按照名称注入。它在给类成员注入时不能单独使用（需要和Autowired一起使用）。但是在给方法参数注入时可以<br>    属性：<br>value：用于指定注入bean的id。    <br><br>@Resource<br>    作用：直接按照bean的id注入。它可以独立使用<br>属性：<br>    name：用于指定bean的id。<br>以上三个注入都只能注入其他bean类型的数据，而基本类型和String类型无法使用上述注解实现。<br>    另外，集合类型的注入只能通过XML来实现。<br><br>@Value<br>    作用：用于注入基本类型和String类型的数据<br>    属性：<br>        value：用于指定数据的值。它可以使用spring中SpEL(也就是spring的el表达式）<br>                SpEL的写法：${表达式}</property></p></blockquote><h2 id="用于改变作用范围"><a href="#用于改变作用范围" class="headerlink" title="用于改变作用范围"></a>用于改变作用范围</h2><blockquote><p>他们的作用就和在bean标签中使用scope属性实现的功能是一样的<br>    @Scope<br>    作用：用于指定bean的作用范围<br>    属性：<br>    value：指定范围的取值。常用取值：singleton prototype</p></blockquote><h2 id="和生命周期相关"><a href="#和生命周期相关" class="headerlink" title="和生命周期相关"></a>和生命周期相关</h2><blockquote><p>他们的作用就和在bean标签中使用init-method和destroy-methode的作用是一样的<br>    @PreDestroy<br>        作用：用于指定销毁方法<br>    @PostConstruct<br>        作用：用于指定初始化方法</p></blockquote><h2 id="配置类里面常用的注解"><a href="#配置类里面常用的注解" class="headerlink" title="配置类里面常用的注解"></a>配置类里面常用的注解</h2><blockquote><p>@Configuration<br>    作用：指定当前类是一个配置类<br>    细节：当配置类为AnnotationConfigApplicationContext对象创建的参数时，该注解可以不写。<br><br>@ComponentScan<br>     作用：用于通过注解指定spring在创建容器时要扫描的包<br>     属性：<br>         value：它和basePackages的作用是一样的，都是用于指定创建容器时要扫描的包。<br>        我们使用此注解就等同于在xml中配置了:<br><code>&lt;context:component-scan base-package=&quot;com.example&quot;&gt;&lt;/context:component-scan&gt;</code><br><br>@Bean<br>    作用：用于把当前方法的返回值作为bean对象存入spring的ioc容器中<br>        属性:<br>    name:用于指定bean的id。当不写时，默认值是当前方法的名称<br>        细节：<br>    当我们使用注解配置方法时，如果方法有参数，spring框架会去容器中查找有没有可用的bean对象。<br>    查找的方式和Autowired注解的作用是一样的<br><br>@Import<br>     作用：用于导入其他的配置类<br> 属性：<br>     value：用于指定其他配置类的字节码。<br>         当我们使用Import的注解之后，有Import注解的类就父配置类，而导入的都是子配置类<br><br>@PropertySource<br>     作用：用于指定properties文件的位置<br>     属性：<br>         value：指定文件的名称和路径。<br>                     关键字：classpath，表示类路径下</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;bean&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;scope&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;  &lt;span class=&quot;attr&quot;&gt;init-method&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;destroy-method&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;property&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;  &lt;span class=&quot;attr&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt; | &lt;span class=&quot;attr&quot;&gt;ref&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;property&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;bean&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Java/Spring/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>【Spring学习笔记1】IOC的创建和Bean的管理</title>
    <link href="http://yoursite.com/2019/10/02/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Spring-study1/"/>
    <id>http://yoursite.com/2019/10/02/Spring学习笔记/Spring-study1/</id>
    <published>2019-10-02T11:19:16.000Z</published>
    <updated>2019-10-02T14:54:34.442Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring-是什么"><a href="#Spring-是什么" class="headerlink" title="Spring 是什么"></a>Spring 是什么</h2><p>分层的轻量型开源框架，以 IoC（Inverse Of Control：反转控制）和 AOP（Aspect Oriented Programming：面向切面编程）为内核</p><a id="more"></a><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ol><li>方便解耦，简化开发<br>通过 Spring提供的 IoC容器，可以将对象间的依赖关系交由 Spring进行控制，避免硬编码所造成的过度程序耦合。用户也不必再为单例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用。</li><li>AOP 编程的支持<br>通过 Spring的 AOP 功能，方便进行面向切面的编程，许多不容易用传统OOP 实现的功能可以通过 AOP 轻松应付。</li><li>声明式事务的支持<br>可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活的进行事务的管理，<br>提高开发效率和质量。</li><li>方便集成各种优秀框架<br>Spring可以降低各种框架的使用难度， 提供了对各种优秀框架 （Struts、 Hibernate、 Hessian、 Quartz<br>等）的直接支持。</li></ol><h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><p>控制反转，将主动创建对象的权利交给Spring框架来管理<br>(在当前类需要用到其他类的对象，由Spring创建，只需要在配置文件中声明依赖关系的维护)<br>目的：降低耦合<br>内部通过工厂模式进行Bean的创建，通过一个Map进行Bean的管理</p><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><p>能注入的数据：有三类</p><blockquote><p>基本类型和String<br>其他bean类型（在配置文件中或者注解配置过的bean）<br>复杂类型/集合类型</p></blockquote><p>注入的方式：有三种</p><blockquote><p>第一种：使用构造函数提供<br>第二种：set方法注入<br>第三种：使用注解注入</p></blockquote><h3 id="构造函数注入"><a href="#构造函数注入" class="headerlink" title="构造函数注入"></a>构造函数注入</h3><blockquote><p>使用的标签:constructor-arg<br>标签中的属性<br>type：用于指定要注入的数据的数据类型，该数据类型也是构造函数中某个或某些参数的类型<br>index：用于指定要注入的数据给构造函数中指定索引位置的参数赋值。索引的位置是从0开始<br>name：用于指定给构造函数中指定名称的参数赋值                                        常用的<br> =============以上三个用于指定给构造函数中哪个参数赋值<br>value：用于提供基本类型和String类型的数据<br>ref：用于指定其他的bean类型数据。它指的就是在spring的Ioc核心容器中出现过的bean对象<br>优势：<br>在获取bean对象时，注入数据是必须的操作，否则对象无法创建成功。<br>弊端：<br>改变了bean对象的实例化方式，使我们在创建对象时，如果用不到这些数据，也必须提供。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">""</span> <span class="attr">class</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"birthday"</span> <span class="attr">ref</span>=<span class="string">"now"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 配置一个日期对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"now"</span> <span class="attr">class</span>=<span class="string">"java.util.Date"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p></blockquote><h3 id="Set方法注入"><a href="#Set方法注入" class="headerlink" title="Set方法注入"></a>Set方法注入</h3><blockquote><p>标签：property<br>出现的位置：bean标签的内部<br>标签的属性<br> name：用于指定注入时所调用的set方法名称<br> value：用于提供基本类型和String类型的数据<br> ref：用于指定其他的bean类型数据。它指的就是在spring的Ioc核心容器中出现过的bean对象<br>优势：<br>   创建对象时没有明确的限制，可以直接使用默认构造函数<br>弊端：<br>   如果有某个成员必须有值，则获取对象是有可能set方法没有执行。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">""</span> <span class="attr">class</span>=<span class="string">""</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--用于给List结构集合注入的标签：</span></span><br><span class="line"><span class="comment">        list array set</span></span><br><span class="line"><span class="comment">用于给Map结构集合注入的标签:</span></span><br><span class="line"><span class="comment">   map  props</span></span><br><span class="line"><span class="comment">结构相同，标签可以互换--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"myList"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>AAA<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>BBB<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>CCC<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p></blockquote><h3 id="接口注入"><a href="#接口注入" class="headerlink" title="接口注入"></a>接口注入</h3><h2 id="ApplicationContext的三个常用实现类"><a href="#ApplicationContext的三个常用实现类" class="headerlink" title="ApplicationContext的三个常用实现类"></a>ApplicationContext的三个常用实现类</h2><p> ClassPathXmlApplicationContext：它可以加载类路径下的配置文件，要求配置文件必须在类路径     下。不在的话，加载不了。(更常用)<br> FileSystemXmlApplicationContext：它可以加载磁盘任意路径下的配置文件(必须有访问权限）<br> AnnotationConfigApplicationContext：它是用于读取注解创建容器的</p><h2 id="ApplicationContext和BeanFactory的区别"><a href="#ApplicationContext和BeanFactory的区别" class="headerlink" title="ApplicationContext和BeanFactory的区别"></a>ApplicationContext和BeanFactory的区别</h2><ul><li><p>BeanFactory：<br>  Spring最底层的接口，各种Bean的定义，配置初始化，实例化，控制bean的生命周期<br>  使用延迟加载，读取配置文件时不会创建对象，使用时才会创建</p></li><li><p>ApplicationContext：<br>  BeanFactory的派生，可进行更多的扩展，继承messagesource 支持国际化，统一资源文件访      问，同时加载多个配置文件，载入多个上下文使每个上下文专注特定层次容器启动时，读取配          置文件后一次性创建所有的Bean，有利于发现配置错误，但占用过多的内存空间</p></li><li><p>区别：<br>BeanFactory 通常以编程方式创建，ApplicationContext 以声明方式创建<br>BeanFactory 延迟加载(创建多例对象使用)，ApplicationContext 立即加载(创建单例对象使用)</p><p>都支持BeanPostProcessor、BeanFactoryPostProcess，BeanFactory需要手动注册，applicationContext自动注册</p></li></ul><h2 id="Spring对Bean的管理细节"><a href="#Spring对Bean的管理细节" class="headerlink" title="Spring对Bean的管理细节"></a>Spring对Bean的管理细节</h2><p>创建Bean的三种方式：</p><ol><li><p>使用默认构造函数创建，在Spring的配置文件中使用bean标签，配以id和class属性之后，且没有其他属性和标签时,采用的就是默认构造函数创建bean对象.此时如果类中没有默认构造函数，则对象无法创建。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">""</span> <span class="attr">class</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用普通工厂中的方法创建对象（使用某个类中的方法创建对象，并存入spring容器）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">""</span> <span class="attr">factory-bean</span>=<span class="string">""</span> <span class="attr">factory-method</span>=<span class="string">""</span> &gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用工厂中的静态方法创建对象（使用某个类中的静态方法创建对象，并存入spring容器)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">""</span> <span class="attr">class</span>=<span class="string">""</span> <span class="attr">factory-method</span>=<span class="string">""</span> &gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><hr><div class="note info">            <p>bean标签的scope属性：<br>  作用：用于指定bean的作用范围<br>  取值： 常用的就是单例的和多例的</p><blockquote><p>singleton：单例的（默认值）<br>prototype：多例的<br>request：作用于web应用的请求范围<br>session：作用于web应用的会话范围<br>global-session：作用于集群环境的会话范围（全局会话范围），当不是集群环境时，它就是session</p></blockquote>          </div><div class="note info">            <p><strong>bean对象的生命周期</strong><br>单例对象</p><blockquote><p>出生：当容器创建时对象出生（解析完配置文件，立即创建）<br>活着：只要容器还在，对象一直活着<br>死亡：容器销毁，对象消亡<br>总结：单例对象的生命周期和容器相同</p></blockquote><p>多例对象</p><blockquote><p>出生：当我们使用对象时spring框架为我们创建（使用时创建，延迟创建）<br>活着：对象只要是在使用过程中就一直活着。<br>死亡：当对象长时间不用，且没有别的对象引用时，由Java的垃圾回收器回收</p></blockquote>          </div><p>PS.<br>解耦的思路：<br>    第一步：使用反射来创建对象，而避免使用new关键字。<br>    第二步：通过读取配置文件来获取要创建的对象全限定类名。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Spring-是什么&quot;&gt;&lt;a href=&quot;#Spring-是什么&quot; class=&quot;headerlink&quot; title=&quot;Spring 是什么&quot;&gt;&lt;/a&gt;Spring 是什么&lt;/h2&gt;&lt;p&gt;分层的轻量型开源框架，以 IoC（Inverse Of Control：反转控制）和 AOP（Aspect Oriented Programming：面向切面编程）为内核&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Java/Spring/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>MySQL中char和varchar的区别</title>
    <link href="http://yoursite.com/2019/09/26/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%B8%ADchar%EF%BC%8Cvarchar/"/>
    <id>http://yoursite.com/2019/09/26/数据库/mysql中char，varchar/</id>
    <published>2019-09-26T08:42:03.093Z</published>
    <updated>2019-10-02T15:29:29.669Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL中char和varchar"><a href="#MySQL中char和varchar" class="headerlink" title="MySQL中char和varchar"></a>MySQL中char和varchar</h1><p>char长度不变，长度不足时会补空格，取出数据时也会有空格需要进行trim，存取效率要高，英文1字节，汉字2字节</p><a id="more"></a><p>varchar 长度不定，如果长度不足，长度会自动转换，更节省空间，英文汉字都是2字节</p>]]></content>
    
    <summary type="html">
    
      mysql,char,varchar
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Hello Hexo</title>
    <link href="http://yoursite.com/2018/03/23/Hello-Hexo/"/>
    <id>http://yoursite.com/2018/03/23/Hello-Hexo/</id>
    <published>2018-03-23T06:45:31.000Z</published>
    <updated>2018-03-23T06:47:36.859Z</updated>
    
    <content type="html"><![CDATA[<p>This is my first test on githubBlog by hexo.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;This is my first test on githubBlog by hexo.&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/03/23/hello-world/"/>
    <id>http://yoursite.com/2018/03/23/hello-world/</id>
    <published>2018-03-23T03:05:38.274Z</published>
    <updated>2019-10-02T15:29:58.639Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="http://yoursite.com/categories/Web/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
      <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
  </entry>
  
</feed>
